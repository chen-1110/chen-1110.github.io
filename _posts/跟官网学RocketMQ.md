---
title: 跟官方文档学rocketmq
author: chen
date: 2024-12-06
category: 技术文章
layout: post
mermaid: true
---

# 跟官方文档学rocketmq

![主题](https://rocketmq.apache.org/zh/assets/images/archifortopic-ef512066703a22865613ea9216c4c300.png)

## 一、基本概念

### 主题（Topic）

用于标识同一类业务逻辑的消息。主题通过TopicName来做唯一标识和区分

### 消息类型（MessageType）

 RocketMQ 支持的消息类型有普通消息、顺序消息、事务消息和定时/延时消息。

### 消息队列（MessageQueue）

消息存储和传输的实际容器，消息的最小存储单元，一个topic由多个队列组成（从而做到可水平拆分）

### 消息标签（MessageTag）

可以在主题层级之下做消息类型的细分。消费者通过订阅特定的标签来实现细粒度过滤

### 消息位点（MessageQueueOffset）

每条消息在队列中都有一个唯一的Long类型坐标

### 消费位点（ConsumerOffset）

一条消息被某个消费者消费完成后不会立即从队列中删除，Apache RocketMQ 会基于**每个消费者分组记录**消费过的最新一条消息的位点，即消费位点

### 消费者分组（ConsumerGroup）

消费者分组是Apache RocketMQ 系统中承载多个消费行为一致的消费者的负载均衡分组。**和消费者不同，消费者分组并不是运行实体，而是一个逻辑资源**。在 Apache RocketMQ 中，通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾。更多信息，请参见[消费者分组（ConsumerGroup）](https://rocketmq.apache.org/zh/docs/domainModel/07consumergroup)。

### 订阅关系（Subscription）

订阅关系是Apache RocketMQ 系统中消费者获取消息、处理消息的规则和状态配置。订阅关系由**消费者分组**动态注册到服务端系统，并在后续的消息传输中按照订阅关系定义的过滤规则进行消息匹配和消费进度维护。更多信息，请参见[订阅关系（Subscription）](https://rocketmq.apache.org/zh/docs/domainModel/09subscription)。

### 消息过滤

消费者可以通过订阅指定消息标签**（MessageTag）**对消息进行过滤，确保最终只接收被过滤后的消息合集。过滤规则的计算和匹配在Apache RocketMQ 的服务端完成。更多信息，请参见[消息过滤](https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter)。





# 二、领域模型

## 2.1 概述

主流的消息中间件的传输模型主要为点对点模型和发布订阅模型

**点对点模型** 

- 一对一通信![点对点模型](https://rocketmq.apache.org/zh/assets/images/p2pmode-fefdc2fbe4792e757e26befc0b3acbff.png)

**发布订阅模型**

![发布订阅模型](https://rocketmq.apache.org/zh/assets/images/pubsub-042a4e5e5d76806943bd7dcfb730c5d5.png)

发布订阅模型具有如下特点：

- 消费独立：相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。
- 一对多通信：基于独立身份的设计，同一个主题内的消息**可以被多个订阅组处理，每个订阅组都可以拿到全量消息**。因此发布订阅模型可以实现一对多通信。



## 2.2 主题（topic）

#### **类型**

- Normal：[普通消息](https://rocketmq.apache.org/zh/docs/featureBehavior/01normalmessage)，消息本身无特殊语义，消息之间也没有任何关联。
- FIFO：[顺序消息](https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage)，Apache RocketMQ 通过消息分组MessageGroup标记一组特定消息的先后顺序，可以保证消息的投递顺序严格按照消息发送时的顺序。
- Delay：[定时/延时消息](https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage)，通过指定延时时间控制消息生产后不要立即投递，而是在延时间隔后才对消费者可见。
- Transaction：[事务消息](https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage)，Apache RocketMQ 支持分布式事务消息，支持应用数据库更新和消息调用的事务一致性保障。

#### 强校验规则

- 同一主题消息类型一致
- 同一主题消息类型单一

#### 最佳实践

主题拆分，应将相同业务域同一功能属性的消息划分为同一主题，同意主题内，消息类型一致，业务相关，量级一致

**正确拆分示例：** 线上商品购买场景下，订单交易如订单创建、支付、取消等流程消息使用一个主题，物流相关消息使用一个主题，积分管理相关消息使用一个主题。



## 2.3 队列

每个主题由多个队列组成，以此实现队列数量的水平拆分和队列内部的流式存储。

作用：

1. 存储顺序性
2. 流式读取（可从任意offset消费读取）

**一个队列只会由一个消费者处理**

#### 最佳实践

队列数量可在创建主题时修改，省着点用，避免压力

> **按照实际业务消耗设置队列数**
>
> Apache RocketMQ 的队列数可在创建主题或变更主题时设置修改，队列数量的设置应遵循少用够用原则，避免随意增加队列数量。
>
> 主题内队列数过多可能对导致如下问题：
>
> - 集群元数据膨胀
>
>   Apache RocketMQ 会以队列粒度采集指标和监控数据，队列过多容易造成管控元数据膨胀。
>
> - 客户端压力过大
>
>   Apache RocketMQ 的消息读写都是针对队列进行操作，队列过多对应更多的轮询请求，增加系统负荷。
>
> **常见队列增加场景**
>
> - 需要增加队列实现物理节点负载均衡
>
>   Apache RocketMQ 每个主题的多个队列可以分布在不同的服务节点上，在集群水平扩容增加节点后，为了保证集群流量的负载均衡，建议在新的服务节点上新增队列，或将旧的队列迁移到新的服务节点上。
>
> - 需要增加队列实现顺序消息性能扩展
>
>   在 Apache RocketMQ 服务端4.x版本中，顺序消息的顺序性在队列内生效的，因此顺序消息的并发度会在一定程度上受队列数量的影响，因此建议仅在系统性能瓶颈时再增加队列。



## 2.4 消息

特点:

1. 消息不可变
2. 消息持久化

普通，顺序消息最大 4M，事务，延时消息最大64KB



## 2.5 生产者

发送方式：同步，异步两种

可批量发送

生产者和主题是多对多的关系，从而水平扩展

内部属性:

- 客户端id
- 通信参数
  - 接入点信息：应该就是nameServer的域名
  - 身份认证信息
  - 请求超时时间
- 预绑定主题列表
  - 这个感觉没看懂，再看看

> ## 使用建议
>
> **不建议单一进程创建大量生产者**
>
> Apache RocketMQ 的生产者和主题是多对多的关系，支持同一个生产者向多个主题发送消息。对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则，如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。
>
> **不建议频繁创建和销毁生产者**
>
> Apache RocketMQ 的生产者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次发送消息时动态创建生产者，且在发送结束后销毁生产者。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。



## 2.6 消费者分组（ConsumerGroup）

是多个行为一致的消费者的集合

- 订阅关系一致（订阅哪些topic，哪些messageTag）
- 投递顺序性（顺序投递/并发投递）
- 重试策略

不是运行实体，是逻辑概念

#### 最佳实践

- 投递顺序一致
- 不同业务域主题建议使用不同消费者分组，避免一个消费者分组消费超过10个主题



## 2.7 消费者

运行实体

#### 重要概念

- 消费身份：消费者必须关联一个消费者组
- 消费者类型：包括PushConsumer类型、SimpleConsumer类型、PullConsumer类型（仅推荐流处理场景使用）等
- 运行配置：消费者客户端线程数，并发度等
- **一个队列只会由一个消费者处理**

#### 内部属性

消费者分组名称

客户端ID

通信参数

​	接入点：服务端域名

​	身份认证信息

​	超时时间

预绑定订阅关系列表

消费监听器

#### 最佳实践

1. 单一进程内同一个消费分组只需要初始化唯一的一个消费者即可，开发过程中应避免以相同的配置初始化多个消费者。

2. 不建议频繁创建和销毁消费者

   



## 2.8 订阅关系（很重要！！）

是什么？

是消费者组处理消息规则的配置，由消费者分组动态注册到服务端

通过订阅关系，可以控制以下：

1. 消息messageTag过滤规则
2. 消费状态，消费者离线后重新上线可以继续上次消费位置消费



**一个队列只会由一个消费者处理**



两张图理解一下：

- 不同消费者分组对于同一个主题的订阅相互独立如下图所示，消费者分组Group A和消费者分组Group B分别以不同的订阅关系订阅了同一个主题Topic A，这两个订阅关系互相独立，可以各自定义，不受影响。

  ![订阅关系不同分组](https://rocketmq.apache.org/zh/assets/images/subscription_diff_group-0b215b9bb822b4bf43c388e9155ecca1.png)

- 同一个消费者分组对于不同主题的订阅也相互独立如下图所示，消费者分组Group A订阅了两个主题Topic A和Topic B，对于Group A中的消费者来说，订阅的Topic A为一个订阅关系，订阅的Topic B为另外一个订阅关系，且这两个订阅关系互相独立，可以各自定义，不受影响。

  ![订阅关系相同分组](https://rocketmq.apache.org/zh/assets/images/subscription_one_group-77bd92b987e8264ad3c5f27b29463942.png)

# 三、功能特性

## 3.1普通消息（略）

## 3.2 定时/延时消息

#### 原理

设置消费时刻时间戳，生产者发送到rocketmq服务端后，会暂存，直到定时时间才放到队列中可消费

秒级精度

#### 使用建议

避免大量相同时刻的定时消息，会导致同一时刻大量消息投递到队列，系统压力大，以及消费延迟

## 3.3 顺序消息

![顺序存储逻辑](https://rocketmq.apache.org/zh/assets/images/fifomessagegroup-aad0a1b7e64089075db956c0eca0cbf4.png)

#### 大致原理

通过将需要顺序处理的消息设置同意消费者组，rocketmq服务端保证同一消费者组消息投递到同一队列（一个队列只会由一个消费者处理），从而保证顺序处理

#### 如何保证顺序性

生产顺序性

- 需要保证单一生产者（不一定是单实例，也可以用锁，不同消息组等方式来实现，只要生产者能保证消息生产顺序性即可）
- 串行生产发送

消费顺序性

- 业务方处理顺序，比如批量消费时，需保证消费顺序性
- 消息重试处理，避免因消息重试带来的问题

#### **生产顺序性和消费顺序性组合**

| 生产顺序                       | 消息类型 | 消费顺序 | 顺序性效果                                                   |
| ------------------------------ | -------- | -------- | ------------------------------------------------------------ |
| 设置消息组，保证消息顺序发送。 | 顺序消息 | 顺序消费 | 按照消息组粒度，严格保证消息顺序。 同一消息组内的消息的消费顺序和发送顺序完全一致。 |
| 设置消息组，保证消息顺序发送。 | 顺序消息 | 并发消费 | 并发消费，尽可能按时间顺序处理。                             |
| 未设置消息组，消息乱序发送。   | 普通消息 | 顺序消费 | 按队列存储粒度，严格顺序。 基于 Apache RocketMQ 本身队列的属性，消费顺序和队列存储的顺序一致，但不保证和发送顺序一致。 |
| 未设置消息组，消息乱序发送。   | 普通消息 | 并发消费 | 并发消费，尽可能按照时间顺序处理。                           |

顺序消息消费失败进行消费重试时，为保障消息的顺序性，后续消息不可被消费，必须等待前面的消息消费完成后才能被处理

#### 使用建议

1. 建议串行消费，避免乱序

> 例如：发送顺序为1->2->3->4，消费时批量消费，消费顺序为1->23（批量处理，失败）->23（重试处理）->4，此时可能由于消息3的失败导致消息2被重复处理，最后导致消息消费乱序。

2. 消息组尽量打散，比如用userId，订单id，避免大量消息打入一个消费队列，产生热点从而导致延迟



## 3.4 消息发送重试和流控机制

#### 概念

1. 发送重试

   发送消息时，可能因为网络，服务异常等原因发送失败，会进行发送重试，生产者可配置最大重试次数

消息重试可能会引起重复问题，需要业务方自己做幂等

2. 流控

   消息堆积，存储压力大等原因会导致限流，报错530，too many request，遇到这种情况，要么加资源，要么生产做降级

## 3.5 消费者分类

#### 概念

三种消费者： pushConsumer  simpleConsumer  pullConsumer   

pushConsumer:  业务开发最常用，无脑用，实现原理也是pull拉模式，开了长轮询线程定时拉取消息

simpleConsumer: 更灵活定制化操作，可考虑

pullConsumer: 极少见，仅在流处理场景有使用，日常业务开发不用

> | 对比项         | PushConsumer                                                 | SimpleConsumer                                       | PullConsumer                                       |
> | -------------- | ------------------------------------------------------------ | ---------------------------------------------------- | -------------------------------------------------- |
> | 接口方式       | 使用监听器回调接口返回消费结果，消费者仅允许在监听器范围内处理消费逻辑。 | 业务方自行实现消息处理，并主动调用接口返回消费结果。 | 业务方自行按队列拉取消息，并可选择性地提交消费结果 |
> | 消费并发度管理 | 由SDK管理消费并发度。                                        | 由业务方消费逻辑自行管理消费线程。                   | 由业务方消费逻辑自行管理消费线程。                 |
> | 负载均衡粒度   | 5.0 SDK是消息粒度，更均衡，早期版本是队列维度                | 消息粒度，更均衡                                     | 队列粒度，吞吐攒批性能更好，但容易不均衡           |
> | 接口灵活度     | 高度封装，不够灵活。                                         | 原子接口，可灵活自定义。                             | 原子接口，可灵活自定义。                           |
> | 适用场景       | 适用于无自定义流程的业务消息开发场景。                       | 适用于需要高度自定义业务流程的业务开发场景。         | 仅推荐在流处理框架场景下集成使用                   |
>
> 

#### 使用建议

使用pushconsumer要注意控制消费耗时，避免因业务长耗时导致消息重复



## 3.6 消息过滤

#### 概念

根据消息tag等过滤规则，apache服务端将满足条件的消息投递给消费者消费

匹配规则主要是用tag匹配，可以单tag也可以多tag，甚至也有自定义sql匹配规则，公司业务主要为单tag场景

#### 使用建议

合理划分主题和tag来做业务区分，同一业务域不同类型消息可以用同一topic不同tag，如果消息量级和重要性有重要区别应该采用不同topic



## 3.7 消费者负载均衡

#### 概念

1. 消费类型有两种，广播消费和共享（集群）消费，广播消费一条消息消费者组只会有一个消费者实例，共享消费消费者组中有多个实例

2. 消费者负载均衡有两种类型（5.0版本）

   消息粒度：pushConsumer和simpleConsumer默认策略

   队列粒度：pullConsumer默认策略



### 消息粒度负载均衡

#### 优点

解决了旧版本一个消费者只能消费一个队列的无法水平扩展的性能问题

消费者更均衡，避免了消费压力旱涝分化

弱化了队列数量的概念，运维简单，更好拥抱云原生

#### 普通消息

![消息粒度负载](https://rocketmq.apache.org/zh/assets/images/clustermode-dfd781d08bc0c69111841bda537aa302.png)

原理：一个队列会被消费者组中的多个消费者实例消费，消费者实例获取某条消息会对消息加锁从而避免被其他消费者实例重复消费

#### 顺序消息

![顺序消息负载策略](https://rocketmq.apache.org/zh/assets/images/fifoinclustermode-60b2f917ab49333f93029cee178b13f0.png)



原理：同一消息组的消息，m1消息未消费完成会锁定后续消息，直到m1消费完成



### 队列维度负载均衡

旧版本以及pullconsumer还在使用，原理即一个队列只能被消费者组中单一消费者消费，若消费者组中消费者数大于队列数，将空闲



### 使用建议

消费者扩缩容，上下线会触发负载均衡分配动作，会出现少量消息重复，建议消费逻辑做好幂等保护





## 3.8 消费进度管理

#### 概念

消息位点：

最小消息位点：接下来消费行为的起始位置

最大消息位点：最后一条消息的位置

消费位点： 每个队列的每个消费者组不同，broker服务端会保存，记录当前消费者组在当前消息队列中的消费位置

> ![消费进度](https://rocketmq.apache.org/zh/assets/images/consumerprogress1-07d9f77dd7e62f2250330ed36f36fe3c.png)
>
> - ConsumerOffset≤MaxOffset：
>   - 当消费速度和生产速度一致，且全部消息都处理完成时，最大消息位点和消费位点相同，即ConsumerOffset=MaxOffset。
>   - 当消费速度较慢小于生产速度时，队列中会有部分消息未消费，此时消费位点小于最大消息位点，即ConsumerOffset<MaxOffset，两者之差就是该队列中堆积的消息量。
> - ConsumerOffset≥MinOffset：正常情况下有效的消费位点ConsumerOffset必然大于等于最小消息位点MinOffset。消费位点小于最小消息位点时是无效的，相当于消费者要消费的消息已经从队列中删除了，是无法消费到的，此时服务端会将消费位点强制纠正到合法的消息位点。

重置消费点位：可重置到最大消息位点，解决消息堆积快速处理，也可以重置到某一时间点位，进行业务补偿回溯（可能会短时间导致大量消息积压），不可重置定时，重试消息



## 3.9 消费重试

发生场景：消费业务逻辑失败，超时

可配置最大重试次数，到达上限进入死信队列不再重试，应避免无线重试

重试时间有阶梯重试策略



## 3.10 消息存储和清理机制

同一apache rocketmq物理节点，所有主题，队列消息存储在一起，在commitlog中，队列中存储消息offset来查找定位

到达保存过期时长或磁盘空间不足时会清理





引用内容：

> # 基本最佳实践
>
> ## 生产者
>
> ### 发送消息注意事项
>
> #### Tag的使用
>
> 一个应用尽可能用一个Topic，而消息子类型则可以用tags来标识。tags可以由应用自由设置，只有生产者在发送消息设置了tags，消费方在订阅消息时才可以利用tags通过broker做消息过滤，5.x SDK 可以调用messageBuilder.setTag("messageTag")，历史版本可以调用 message.setTags("messageTag")。
>
> #### Keys的使用
>
> 每个消息在业务层面一般建议映射到业务的唯一标识并设置到keys字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过topic、key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。常见的设置策略使用订单Id、用户Id、请求Id等比较离散的唯一标识来处理。
>
> #### 日志的打印
>
> 消息发送成功或者失败要打印消息日志，用于业务排查问题。Send消息方法只要不抛异常，就代表发送成功。
>
> ### 消息发送失败处理方式
>
> Producer的send方法本身支持内部重试，5.x SDK的重试逻辑参考[发送重试策略](https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy)：
>
> 以上策略也是在一定程度上保证了消息可以发送成功。如果业务要求消息发送不能丢，仍然需要对可能出现的异常做兜底，比如调用send同步方法发送失败时，则尝试将消息存储到db，然后由后台线程定时重试，确保消息一定到达Broker。
>
> 上述DB重试方式为什么没有集成到MQ客户端内部做，而是要求应用自己去完成，主要基于以下几点考虑：首先，MQ的客户端设计为无状态模式，方便任意的水平扩展，且对机器资源的消耗仅仅是cpu、内存、网络。其次，如果MQ客户端内部集成一个KV存储模块，那么数据只有同步落盘才能较可靠，而同步落盘本身性能开销较大，所以通常会采用异步落盘，又由于应用关闭过程不受MQ运维人员控制，可能经常会发生 kill -9 这样暴力方式关闭，造成数据没有及时落盘而丢失。第三，Producer所在机器的可靠性较低，一般为虚拟机，不适合存储重要数据。综上，建议重试过程交由应用来控制。
>
> ## 消费者
>
> ### 消费过程幂等
>
> RocketMQ 无法避免消息重复（Exactly-Once），所以如果业务对消费重复非常敏感，务必要在业务层面进行去重处理。可以借助关系数据库进行去重。首先需要确定消息的唯一键，可以是msgId，也可以是消息内容中的唯一标识字段，例如订单Id等。在消费之前判断唯一键是否在关系数据库中存在。如果不存在则插入，并消费，否则跳过。（实际过程要考虑原子性问题，判断是否存在可以尝试插入，如果报主键冲突，则插入失败，直接跳过）
>
> msgId一定是全局唯一标识符，但是实际使用中，可能会存在相同的消息有两个不同msgId的情况（消费者主动重发、因客户端重投机制导致的重复等），这种情况就需要使业务字段进行重复消费。
>
> ### 消费速度慢的处理方式
>
> ### 提高消费并行度
>
> 绝大部分消息消费行为都属于 IO 密集型，即可能是操作数据库，或者调用 RPC，这类消费行为的消费速度在于后端数据库或者外系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。所以，应用必须要设置合理的并行度。 如下有几种修改消费并行度的方法：
>
> - 同一个 ConsumerGroup 下，通过增加 Consumer 实例数量来提高并行度。可以通过加机器，或者在已有机器启动多个进程的方式。
> - 提高单个 Consumer 的消费并行线程，5.x PushConsumer SDK 可以通过PushConsumerBuilder.setConsumptionThreadCount() 设置线程数，SimpleConsumer可以由业务线程自由增加并发，底层线程安全；历史版本SDK PushConsumer可以通过修改参数 consumeThreadMin、consumeThreadMax实现。
>
> ### 批量方式消费
>
> 某些业务流程如果支持批量方式消费，则可以很大程度上提高消费吞吐量，例如订单扣款类应用，一次处理一个订单耗时 1 s，一次处理 10 个订单可能也只耗时 2 s，这样即可大幅度提高消费的吞吐量。建议使用5.x SDK的SimpleConsumer，每次接口调用设置批次大小，一次性拉取消费多条消息。
>
> ### 重置位点跳过非重要消息
>
> 发生消息堆积时，如果消费速度一直追不上发送速度，如果业务对数据要求不高的话，可以选择丢弃不重要的消息。建议使用重置位点功能直接调整消费位点到指定时刻或者指定位置。
>
> #### 优化每条消息消费过程
>
> 举例如下，某条消息的消费过程如下：
>
> - 根据消息从 DB 查询【数据 1】
> - 根据消息从 DB 查询【数据 2】
> - 复杂的业务计算
> - 向 DB 插入【数据 3】
> - 向 DB 插入【数据 4】
>
> 这条消息的消费过程中有4次与 DB的 交互，如果按照每次 5ms 计算，那么总共耗时 20ms，假设业务计算耗时 5ms，那么总过耗时 25ms，所以如果能把 4 次 DB 交互优化为 2 次，那么总耗时就可以优化到 15ms，即总体性能提高了 40%。所以应用如果对时延敏感的话，可以把DB部署在SSD硬盘，相比于SCSI磁盘，前者的RT会小很多。
>
> ### 消费打印日志
>
> 如果消息量较少，建议在消费入口方法打印消息，消费耗时等，方便后续排查问题。
>
> ```java
>    new MessageListener() {
>         @Override
>         public ConsumeResult consume(MessageView messageView) {
>             LOGGER.info("Consume message={}", messageView);
>             //Do your consume process
>             return ConsumeResult.SUCCESS;
>             }
>     }
> ```
>
> 
>
> 如果能打印每条消息消费耗时，那么在排查消费慢等线上问题时，会更方便。但如果线上环境TPS很高，不建议开启，避免日志太多影响性能。
>
> ## Broker
>
> ### Broker 角色
>
> Broker 角色分为 ASYNC_MASTER（异步主机）、SYNC_MASTER（同步主机）以及SLAVE（从机）。如果对消息的可靠性要求比较严格，可以采用 SYNC_MASTER加SLAVE的部署方式。如果对消息可靠性要求不高，可以采用ASYNC_MASTER加SLAVE的部署方式。如果只是测试方便，则可以选择仅ASYNC_MASTER或仅SYNC_MASTER的部署方式。
>
> ### FlushDiskType
>
> SYNC_FLUSH（同步刷新）相比于ASYNC_FLUSH（异步处理）会损失很多性能，但是也更可靠，所以需要根据实际的业务场景做好权衡。







> 消息过滤sql匹配规则场景示例：
>
> 以下图电商交易场景为例，从客户下单到收到商品这一过程会生产一系列消息，按照类型将消息分为订单消息和物流消息，其中给物流消息定义地域属性，按照地域分为杭州和上海：
>
> - 订单消息
> - 物流消息
>   - 物流消息且地域为杭州
>   - 物流消息且地域为上海
>
> 这些消息会发送到名称为Trade_Topic的Topic中，被各个不同的系统所订阅：
>
> - 物流系统1：只需订阅物流消息且消息地域为杭州。
> - 物流系统2：只需订阅物流消息且消息地域为杭州或上海。
> - 订单跟踪系统：只需订阅订单消息。
> - 实时计算系统：需要订阅所有和交易相关的消息。
>
> 过滤效果如下图所示：![sql过滤](https://rocketmq.apache.org/zh/assets/images/messagefilter2-dbf55cf4a63ac6d3b9c5f02603ce92ce.png)
>
> **消息属性设置**
>
> 生产者发送消息时可以自定义消息属性，每个属性都是一个自定义的键值对（Key-Value）。
>
> 每条消息支持设置多个属性。
>
> **SQL属性过滤规则**
>
> SQL属性过滤使用SQL92语法作为过滤规则表达式，语法规范如下：
>
> | 语法                    | 说明                                                         | 示例                                                         |
> | ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | IS NULL                 | 判断属性不存在。                                             | `a IS NULL` ：属性a不存在。                                  |
> | IS NOT NULL             | 判断属性存在。                                               | `a IS NOT NULL`：属性a存在。                                 |
> | *>* >= *<* <=           | 用于比较数字，不能用于比较字符串，否则消费者客户端启动时会报错。 **说明** 可转化为数字的字符串也被认为是数字。 | *`a IS NOT NULL AND a > 100`：属性a存在且属性a的值大于100。* `a IS NOT NULL AND a > 'abc'`：错误示例，abc为字符串，不能用于比较大小。 |
> | BETWEEN xxx AND xxx     | 用于比较数字，不能用于比较字符串，否则消费者客户端启动时会报错。等价于>= xxx AND \<= xxx。表示属性值在两个数字之间。 | `a IS NOT NULL AND (a BETWEEN 10 AND 100)`：属性a存在且属性a的值大于等于10且小于等于100。 |
> | NOT BETWEEN xxx AND xxx | 用于比较数字，不能用于比较字符串，否则消费者客户端启动会报错。等价于\< xxx OR > xxx，表示属性值在两个值的区间之外。 | `a IS NOT NULL AND (a NOT BETWEEN 10 AND 100)`：属性a存在且属性a的值小于10或大于100。 |
> | IN (xxx, xxx)           | 表示属性的值在某个集合内。集合的元素只能是字符串。           | `a IS NOT NULL AND (a IN ('abc', 'def'))`：属性a存在且属性a的值为abc或def。 |
> | *=* <>                  | 等于和不等于。可用于比较数字和字符串。                       | `a IS NOT NULL AND (a = 'abc' OR a<>'def')`：属性a存在且属性a的值为abc或a的值不为def。 |
> | *AND* OR                | 逻辑与、逻辑或。可用于组合任意简单的逻辑判断，需要将每个逻辑判断内容放入括号内。 | `a IS NOT NULL AND (a > 100) OR (b IS NULL)`：属性a存在且属性a的值大于100或属性b不存在。 |
>
> 由于SQL属性过滤是生产者定义消息属性，消费者设置SQL过滤条件，因此过滤条件的计算结果具有不确定性，服务端的处理方式如下：
>
> - 异常情况处理：如果过滤条件的表达式计算抛异常，消息默认被过滤，不会被投递给消费者。例如比较数字和非数字类型的值。
> - 空值情况处理：如果过滤条件的表达式计算值为null或不是布尔类型（true和false），则消息默认被过滤，不会被投递给消费者。例如发送消息时未定义某个属性，在订阅时过滤条件中直接使用该属性，则过滤条件的表达式计算结果为null。
> - 数值类型不符处理：如果消息自定义属性为浮点型，但过滤条件中使用整数进行判断，则消息默认被过滤，不会被投递给消费者。
>
> **使用示例**
>
> - 发送消息，同时设置消息Tag标签和自定义属性。
>
>   ```java
>   Message message = messageBuilder.setTopic("topic")
>   //设置消息索引键，可根据关键字精确查找某条消息。
>   .setKeys("messageKey")
>   //设置消息Tag，用于消费端根据指定Tag过滤消息。
>   //该示例表示消息的Tag设置为"messageTag"。
>   .setTag("messageTag")
>   //消息也可以设置自定义的分类属性，例如环境标签、地域、逻辑分支。
>   //该示例表示为消息自定义一个属性，该属性为地域，属性值为杭州。
>   .addProperty("Region", "Hangzhou")
>   //消息体。
>   .setBody("messageBody".getBytes())
>   .build();
>   ```
>
>   
>
> - 订阅消息，根据单个自定义属性匹配消息。
>
>   ```java
>   String topic = "topic";
>   //只订阅地域属性为杭州的消息。
>   FilterExpression filterExpression = new FilterExpression("Region IS NOT NULL AND Region='Hangzhou'", FilterExpressionType.SQL92);
>   simpleConsumer.subscribe(topic, filterExpression);
>   ```
>
>   
>
> - 订阅消息，同时根据多个自定义属性匹配消息。
>
>   ```java
>   String topic = "topic";
>   //只订阅地域属性为杭州且价格属性大于30的消息。
>   FilterExpression filterExpression = new FilterExpression("Region IS NOT NULL AND price IS NOT NULL AND Region = 'Hangzhou' AND price > 30", FilterExpressionType.SQL92);
>   simpleConsumer.subscribe(topic, filterExpression);
>   ```
>
>   
>
> - 订阅消息，匹配Topic中的所有消息，不进行过滤。
>
>   ```java
>   String topic = "topic";
>   //订阅所有消息。
>   FilterExpression filterExpression = new FilterExpression("True", FilterExpressionType.SQL92);
>   simpleConsumer.subscribe(topic, filterExpression);
>   ```

