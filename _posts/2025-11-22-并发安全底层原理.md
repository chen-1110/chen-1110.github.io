---
layout: post
categories: 整理记录
author: chen
title: 并发安全底层原理
---
## 一、知识扫盲

上一篇我们基本了解了多线程及其用途，多线程在提供高性能的同时也引入了并发安全问题，共享数据的修改容易引来意想不到的逻辑错误，这一篇我们讨论下并发安全问题的多个方面及jvm为我们提供的安全机制。

## 二、为什么需要并发安全

### 并发安全的两个层次

在谈并发安全之前，我们首先要声明，并发安全问题发生的前提是，多个线程共享一组内存空间（变量）的读写，在并发操作时发生逻辑错误。

并发安全可以从两个角度来看，
对于初级工程师来说，自然能够想到，多个线程操作同一变量，需要使用锁等同步机制保证操作的先后顺序，使得程序逻辑按照开发者预想的顺序进行。

第二个层次的并发安全，发生在如果我们进行更广泛的开发探索，会意外地发现，计算机的机器执行并不是我们程序语法预想的简单清晰，其中有很多肉眼无法见的底层优化，包括cpu寄存器缓存，l1，l2缓存，指令重排（jvm提供）等。这些硬件优化往往会使我们的程序出现意想不到的错误，比如以下代码，执行的时候，t1线程将永远无法跳出循环，这与我们对于程序逻辑的直接理解是相悖反直觉的。

```java
public class BadCase1 {
    public static boolean run = true;
    public static void main(String[] args) {
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                while (run) {
                    
                }
                System.out.println("t1 end");
            }
        };

        t1.start();
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        run = false;
    }
}
```

而只要我们做一些简单的改动，t1循环便能按我们的程序理解跳出循环，按照直觉运行。比如，在8行加上一条日志打印，再比如，在2行run变量加上volatile关键字。接下来我们将重点讨论第二个层次的并发安全。

### 底层发生了什么

我们继续看上面的badCase代码，底层发生了什么导致这样的结果。先说答案，我不知道，看到这里很多读者会相当失望，同样的当我探究该问题时得到薛定谔的猫这样的结果的时候，我也是相当失望的，但是不要着急，接着看下去你会和我一样释然的。

我们先看下底层会替我们做什么。

1.cpu缓存

作为后端开发，使用redis等内存型数据库来加速访问是常见的应用方案，cpu计算同样如此，在内存（主存）之上采用更小更快速更贵的cpu cache来加速访问已经是各类常见cpu的使用方案，在我们的程序中，run的bool值保存在主存里（方法区），但是cpu在运算时不一定每次都读取主存，硬件会根据运行逻辑场景动态选择是否重载主存。

![缓存一致性协议](https://raw.githubusercontent.com/chen-1110/image/main/cpu-cache-protocol.png)

2.指令重排序

我们写好的java代码，到cpu执行，经历jvm编译为字节码，jvm将字节码指令解释为机器指令，cpu执行机器指令这几个过程，在这个过程中编译和解释都会发生指令重排序和优化，重排序的目的当然是为了增加并行，提高运行速度。单线程场景下这些重排不会出现问题，但是多线程便会遇到问题，比如上面badCase代码，便可能会被重排为类似下面的代码逻辑，从而出错。

```
public class BadCase1 {
    public static boolean run = true;
    public static void main(String[] args) {
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
            	boolean t1Run = run;
                while (t1Run) {
                    
                }
                System.out.println("t1 end");
            }
        };

        t1.start();
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        run = false;
    }
}
```

## 三、并发安全如何解决

### happens-before规则

上文我们已经讲了由于底层做了优化，导致程序出现反直觉的错误，那么这类错误该如何避免呢？java语言是提供了多种语法/关键字来处理该问题，但是这不应该是我们思考的出发点。或者这么来说，现代cpu类型日新月异，每种cpu可能有不同的硬件底层实现，而应用开发语言也是多种多样的，我们思考的出发点应该是，从程序员的视角抽象来看，底层（可以是硬件，开发语言等）会做开不到的优化，上层程序/代码又开发人员控制逻辑。**应用程序员需要的是，能够保证并发安全的，一套上层所遵循的规范，底层优化不会打破规范中的规则，上层只要按照规范开发，就能够保证并发安全。**

这套大名鼎鼎的规范，诞生于1978年的论文[《Time，Clocks and the Ordering of Events in a Distributed System》](https://lamport.azurewebsites.net/pubs/time-clocks.pdf)。这篇论文定义了一套对于时件发生的先后顺序的规则。

java语言在jsr133正式引入了这套规则，并在语法上做了适配，java将这套规则命名为happens-before原则，java程序员只要遵循该规则进行开发即可保障并发安全

happens-before定义：如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。

happens-before规则（**重点**）：

**程序顺序规则**：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；

**解锁规则**：解锁 happens-before 于加锁；

**volatile 变量规则**：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。

**传递规则**：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；

**线程启动规则**：Thread 对象的 `start()`方法 happens-before 于此线程的每一个动作



### JMM模型

刚才讲了happens-before规则，那么JMM模型又是什么呢，首先要强调一下JMM是全称Java Memory Model，这个和java内存区域，堆，栈，方法区那一套是两个东西，不要搞混。

好我们继续说JMM，这个东西名称听着很高大上，但是内容简单到不值5分钱，首先JMM是一个抽象概念，并不是物理存储上的真实分区，可以理解为这是屏蔽了底层硬件细节的程序员视角，具体可以看这张图，这里多线程的本地内存并不是类似栈空间那样的真实空间，而是一种虚拟的抽象概念，它对应的底层就是上面的硬件优化。

![JMM(Java 内存模型)](https://raw.githubusercontent.com/chen-1110/image/main/jmm.png)

### 顶层建筑

上面讲了底层上如何保障并发安全的，现在我们结合java语法看看java提供了哪些顶层建筑，主要有加锁和volatile关键字两个方面，分别对应happens-before里的解锁规则和volatile规则。加锁的方式有synchronized块和Lock两种，volatile就是用在变量上的一个关键字。具体使用细节不展开讲，可以参考初始java多线程交替打印的两个例子。

然后还有一个概念性的知识，并发编程的三个重要特性，原子性只能通过锁以及CAS（后面再说）来实现，可见性和有序性由于上面的两条规则，锁和volatile都能实现

