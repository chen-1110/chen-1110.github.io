---
layout: post
categories: 技术文章
author: chen
title: 初识Java多线程
---
## 1.知识扫盲

一些常识类知识，写在第一节。

进程：一个应用程序就是一个进程（有的是多进程），是系统资源分配的最小单位，os给每个进程分配独享的内存和cpu资源。

线程：cpu调度的最小单位，多个线程共享进程的堆（java对象）和方法区（类信息，常量，jit优化数据）资源，每个线程维护独有的程序计数器（下次执行指令行）和栈空间（局部变量）

java线程和操作系统线程有何区别？

线程分为内核线程和应用线程两种，应用线程和内核线程存在一对一，多对一，多对多三种线程模型，其底层区别在于线程并发是否采用多核，比如多对一场景下的并发只用了单核cpu，jvm规范并没有规定java线程要使用哪种类型，常见的如hotSpot虚拟机里，采用的是一对一的模型，我们也可以认为其用户线程=操作系统内核线程。

## 2.线程的生命周期

![Java 线程状态变迁图](https://raw.githubusercontent.com/chen-1110/image/main/640.png)

简单总结，

1.Object.wait()会让当前线程释放该object的锁，进入waiting状态，若当前线程未持有该object的锁，会抛出异常。Object.notify()会唤醒处于waiting该object锁的线程，尝试获取锁（waiting状态的线程只有被notify才会竞争锁）

2.线程获取锁失败（锁被占用），线程会进入blocked状态，直到获取到锁

3.加上时间戳的wait方法处于time_waiting状态，到期之后会尝试像wait被notify后尝试获取锁，thread.sleep比较特殊，它不会释放锁，到期后直接进入running态。

## 3.为什么需要多线程

从底层来看，目的无非就是想充分发挥cpu（单核/多核）的优势，让应用运行加速。那么为什么需要多线程而不是多进程呢，其实是想在快的基础上又稳定，进程的定义规范对系统资源进行了隔离，避免资源互相抢占污染，从而导致了多进程通信交互的低效率，于是多线程自然成为最佳选择

