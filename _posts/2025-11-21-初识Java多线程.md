---
layout: post
categories: 技术文章
author: chen
title: 初识Java多线程
---
## 1.知识扫盲

一些常识类知识，写在第一节。

进程：一个应用程序就是一个进程（有的是多进程），是系统资源分配的最小单位，os给每个进程分配独享的内存和cpu资源。

线程：cpu调度的最小单位，多个线程共享进程的堆（java对象）和方法区（类信息，常量，jit优化数据）资源，每个线程维护独有的程序计数器（下次执行指令行）和栈空间（局部变量）

java线程和操作系统线程有何区别？

线程分为内核线程和应用线程两种，应用线程和内核线程存在一对一，多对一，多对多三种线程模型，其底层区别在于线程并发是否采用多核，比如多对一场景下的并发只用了单核cpu，jvm规范并没有规定java线程要使用哪种类型，常见的如hotSpot虚拟机里，采用的是一对一的模型，我们也可以认为其用户线程=操作系统内核线程。

## 2.线程的生命周期

![Java 线程状态变迁图](https://raw.githubusercontent.com/chen-1110/image/main/640.png)

简单总结，

1.Object.wait()会让当前线程释放该object的锁，进入waiting状态，若当前线程未持有该object的锁，会抛出IllegalMonitorStateException异常。Object.notify()会唤醒处于waiting该object锁的线程，尝试获取锁（waiting状态的线程只有被notify才会竞争锁）

2.线程获取锁失败（锁被占用），线程会进入blocked状态，直到获取到锁

3.加上时间戳的wait方法处于time_waiting状态，到期之后会尝试像wait被notify后尝试获取锁，thread.sleep比较特殊，它不会释放锁，到期后直接进入running态。

## 3.为什么需要多线程

从底层来看，目的无非就是想充分发挥cpu（单核/多核）的优势，让应用运行加速。那么为什么需要多线程而不是多进程呢，其实是想在快的基础上又稳定，进程的定义规范对系统资源进行了隔离，避免资源互相抢占污染，从而导致了多进程通信交互的低效率，于是多线程自然成为最佳选择



## 4.交替打印奇偶数/取余3余数

方案1，两个线程循环抢锁

```
package com.chen;


public class Main {

    public static volatile int count = 1;

    public static void main(String[] args) throws Exception {

        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                while (true) {
                    if (count > 100) {
                        break;
                    }
                    if (count % 2 == 1) {
                        System.out.println(Thread.currentThread() + ":" + count);
                        count++;
                    }
                }
            }
        };

        Thread t2 = new Thread("t2"){
            @Override
            public void run() {
                while (true) {
                    if (count > 100) {
                        break;
                    }
                    if (count % 2 == 0) {
                        System.out.println(Thread.currentThread() + ":" + count);
                        count++;
                    }
                }
            }
        };


        t1.start();
        t2.start();


    }
}
```

方案2，通过wait/notify两线程互相通知

```
package com.chen;

import lombok.Data;

@Data
public class Test {
	// 这里无需volatile，因为下面synchronized已经保障了happens-before
    public static int count = 1;

    public static Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                while (true) {
                    synchronized (lock) {
                        if (count > 100) {
                            break;
                        }
                        if (count % 2 == 1) {
                            System.out.println(Thread.currentThread() + ":" + count);
                            count++;
                            lock.notify();
                        } else {
                            try {
                                lock.wait();
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }                }

            }
        };

        Thread t2 = new Thread("t2") {
            @Override
            public void run() {
                while (true) {
                    synchronized (lock) {
                        if (count > 100) {
                            break;
                        }
                        if (count % 2 == 0) {
                            System.out.println(Thread.currentThread() + ":" + count);
                            count++;
                            lock.notify();
                        } else {
                            try {
                                lock.wait();
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                }

            }
        };

        t1.start();
        t2.start();
    }
}

```

