---
title: HotSpot JVM初探
author: chen
date: 2021-11-10
category: 技术文章
layout: post
mermaid: true
---
## 1.内容介绍

这篇博客是我在学习jvm之后的总结沉淀，虽然现在市面上对于jvm的解读资料已经有很多了，但是我在初学时并没有找到很适合初学者的角度，我时常在想，我们在学习技术时遇到的难啃的硬骨头到底难度在于技术本身呢还是技术传播者的水平不够到位，答案无从而知，这篇博客则尽力从对于jvm毫不知情的入门者角度对于jvm进行解读。

这篇博客将分为四个部分。主要针对jdk8中的hotspot虚拟机进行讲解（市面上还有大量不同厂商的虚拟机，但是这个是最常用的）

第一部分介绍java代码交给jvm执行的过程细节，这一部分之后我们将不再是java代码的搬运工，而获得了对于系统内存的控制权，十分重要。

第二部分我们将简单地学习阅读字节码指令，一条java语句在前端编译后会变成多条字节码语句，掌握了java语句对应字节码指令操作，我们才能对我们的代码行为具备更强的控制力，此外，在我们编程的过程中，可能会遇到一些奇怪的bug，如下面这段代码所示，运行的结果是（true，flase）

~~~java
Integer a=1;
Integer b=1;
System.out.println(a==b);
Integer c=128;
System.out.println(c==d);
~~~

说实话我个人认为这种bug是难以避免的，只能随着编程经验慢慢踩坑，而字节码的学习就相当于送给你了一本字典，以后遇到奇怪之处我们都可以阅读字节码来排查，而且可以认为字节码是直接与内存对话，所以在字节码层次一定不会出现奇怪的问题。这一部分可以先过个眼熟，作为字典用。

第三部分是垃圾回收章节，我们创建的对象，常量之类的存储在我们的内存中，与c++程序员不同，使用之后我们并不需要对其占用的内存空间进行释放，当占用了一定量的内存空间后会进行回收，这就是我们所说的垃圾回收，这一章我们将介绍垃圾回收的几种算法并介绍运用不同算法的几种经典垃圾回收器，这一章也是很重要的部分，在了解了内存结构后，搭配合理的垃圾回收器并且设置合适的jvm各区域内存空间可以更大程度地利用系统资源，这也是我们java程序员对于系统资源的少之又少的一点控制权了，学习垃圾回收算法并不是高屋建瓴，这些知识实实在在地应用在我们的编码过程。

第四部分是调优工具章节，经过了前面几个章节的学习，我们已经完成了对jvm的入门学习，这一章将介绍几个好用的调优工具，不过说实在的，选择哪一种工具并不是我们调优jvm的银弹，就如同有着顶尖的武器装备的程序员在战场甚至不如一个拿着手枪的士兵，真正的知识在前三章中，这一章是给老虎添上翅膀，但你得先成为一只老虎，这一部分我也只会简单介绍一下。

经过这四个部分的学习，就完成了对于jvm的入门学习，至少你不会再写出糟糕的代码，并且对于jvm调优有了初步的经验，我个人觉得要想成为一位熟练的调优专家理论和实践都是不可缺少的，在互联网上我看到了很多调优相关的实战案例，之后在有时间or工作一段时间后我会再写一篇关于调优实战的博客。

同时这篇博客将作为我的博客风格转变的一篇，之前对于博客内容只是追求对于技术学习的记录，在经历了腾讯实习转正答辩以及看到蘑菇博客转载的“你为什么不分享”的文章后，我对于自己的博客有了新的要求，总结来说，我要写得快又帅，一切拭目以待吧。这篇博客有错误或者模糊的地方欢迎各位大佬的指正，质疑是对我最大的尊重，谢谢大家。



## 2.从java代码到jvm内存结构

![Java 运行时数据区域（JDK1.7）](https://raw.githubusercontent.com/chen-1110/image/main/java-runtime-data-areas-jdk1.7.png)

![Java 运行时数据区域（JDK1.8 ）](https://raw.githubusercontent.com/chen-1110/image/main/java-runtime-data-areas-jdk1.8.png)

### 2.1 概述

jvm是什么，相信java程序员是听过jvm这个词的，全称java virtual machine（java虚拟机），我们在编写java程序时，我们写的代码是由jvm来执行的，不过由于java语言对于jvm的封装相当好，结果很多java程序员不需要了解jvm的运行细节，只要关注java代码就可以了，但是这样也导致了一个问题，不了解jvm的java程序员失去了对计算机资源的控制权，从而导致了写出了很烂的代码。所以要成为一个好的java程序员，jvm是不可躲避的一关，这一章我们将把我们熟悉的java代码执行过程转化为jvm内存结构的变化，从而重新获得对于内存的控制权。

### 2.2 java代码运行发生了什么

首先我想说一句，我们已经用了很久的面向对象语言了，但是不要忘记编程的实质，我们是在执行指令，而代入到java中，我们是在执行方法，java代码的执行实际上就是方法的执行，而和类也好，对象也好毫无关系，面向对象简化了我们的编程，使得代码拥有了很多强大地特性，但是无法改变的是，我们的本质是在执行指令。

ok我们继续讲jvm：

![jvm内存图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/jvm%E5%86%85%E5%AD%98%E5%9B%BE.png)

######                                                                                            																									图1

如图1所示，这是java代码的一生，我们将模拟一遍这个过程来讲解java代码实际执行过程

1. 我们在idea写好了java代码Animal类

~~~java
public class Animal {
    private String name;
    public void test(){
        System.out.println("test");
    }
    public static void main(String[] args) {
        System.out.println("hello,world");
    }
}

~~~

2. 他会首先进行一次编译，编译成字节码文件，这是一组二进制流，如图2，在idea生成的target中我们可以看到

![20210902091655](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/Animal%E5%AD%97%E8%8A%82%E7%A0%81%E5%9B%BE.png)

###### 																																														图2

3. 之后会经过类加载过程，这个过程将字节码转化成了某些数据全部放入了运行时数据区。                                其实并不是所有的类在jvm启动时都会被加载到运行时数据区，只会先加载一部分核心类，之后遇到一些指令（例如new对象）再加载其他类，这样可以节省内存。
4. 这个时候如果要执行某个方法，比如main方法，比如springboot的某个接口，这个时候会在运行时数据区找到要执行的方法的指令，然后通过执行引擎再次编译（解释执行）这些指令，cpu执行。

这就是java代码执行的具体过程，也就是图1中所画的部分，图1中还有本地方法接口没有讲到，读者可以忽略这个东西，这是用来调用非java代码的接口，这是java刚出世的时候为了顺应c语言的市场而提供的，可以让java程序员调用c语言代码，但是这个接口现在用的也已经很少了，读者们可以忽视这个东西。

接下来我们要先讲解运行时数据区，这是我们讲解的重点，然后我们将讲解类加载子系统，（因为类加载子系统是将字节码文件转化为运行时数据区，如果不懂运行时数据区也没法讲这个过程），然后我们将简单提一下前端编译和后端编译的过程（这不是我们的重点）。

###### （ps. 为什么我们要生成字节码文件呢？因为java设计之初希望java虚拟机拥有跨语言的特性，也就是说任何语言凡是编译后满足字节码文件格式的都可以在java虚拟机上运行，而这样的设计确实是成功的，现在的Kotlin，Scala，Jpython等大量语言都可以在java虚拟机上运行）



### 2.3 运行时数据区

运行时数据区分成五个部分，方法区和堆是线程共享的，程序计数器，本地方法栈，虚拟机栈是线程独有的。

#### 2.3.1 程序计数器

用来记录要运行的字节码指令的位置

这一部分时线程私有的，当多个线程切换执行时，每个线程通过自己的程序计数器记录切换后要执行的字节码指令

#### 2.3.2 虚拟机栈

![Java 虚拟机栈](https://raw.githubusercontent.com/chen-1110/image/main/stack-area.png)

######                                                                                                 																								图3

如图3，虚拟机栈首先是是一个栈，用来执行java方法，栈中的存储单位叫做栈帧，每一个方法对应一个栈帧，每一个栈帧中有局部变量表、 操作数栈、 动态连接、 方法返回地址和一些附加信息。

~~~ java
public class Animal {
    private String name;

    public static void test(){
        System.out.println("test");
    }
    public static void main(String[] args) {
        int a=10;
        Animal.test();
        Animal animal=new Animal();
        System.out.println("hello,world");
    }
}
~~~

如上代码所示，首先main方法入栈创建栈帧，main方法在执行到Animal.test()方法时创建新的栈帧，执行test（）方法，在执行完之后test（）方法对应栈帧出栈，栈顶栈帧回归为main方法，接着执行main方法，main方法执行完毕main方法对饮栈帧出栈，栈空，执行结束。

虚拟机栈不会进行垃圾回收，如果栈深度过大会StackOverflow，这也和每一个栈帧的大小有关，如果方法内容都很小的话相应的能容纳的栈深度就会增加。可以用-xss：100m类似的指令指定栈内存大小。虚拟机栈中不存在垃圾回收行为，方法结束，栈帧就出栈消除。

接下来讲解一下栈帧存储了哪些信息

* 局部变量表：

  1.局部变量表为一个数组，存储该栈帧方法执行过程中产生的局部变量，当前方法结束就会销毁局部变量表。

  2.如上代码在执行main方法时执行语句int a=10就在局部变量表第一个位置存储a，执行Animal animal=new Animal()时就在局部变量表第二个位置存储animal。

  3.代码块在执行结束后原先局部变量存储的内容可以被后面的新产生的局部变量覆盖

  4.非静态的方法局部变量表第一个位置为该对象的this引用

  5.局部变量也是之后垃圾回收章节垃圾是否回收的关键因素，之后会讲，埋个伏笔。

  6.局部变量表的数组长度在编译成字节码文件后就已经确定。

* 操作数栈

  操作数栈也是一个栈，是用来计算的临时空间（类似于计组里面的寄存器）

  ![操作数栈演示图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E6%BC%94%E7%A4%BA%E5%9B%BE.png)

  ######                                                                                           																					图4

  例如图4中的代码，操作数栈进行了如下操作

  将15放入操作数栈

  局部变量表中存入i=15，15出栈

  将8放入操作数栈

  局部变量表中存入j=8，8出栈

  局部变量表中取出15和8放入操作数栈

  取出操作数栈中15和8进行运算，15和8出栈

  将结果23放入操作数栈

  局部变量表中存入k=23，23出栈

  ![操作数栈代码追踪图1](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA%E5%9B%BE1.png)

  ![操作数栈代码追踪图2](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA%E5%9B%BE2.png)

  ![操作数栈代码追踪图3](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA%E5%9B%BE3.png)

  ![操作数栈代码追踪图4](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA%E5%9B%BE4.png)

  我们一般说jvm的解释引擎是基于栈的指令集指的也是操作数栈的执行过程，还有另一种的解释引擎是基于寄存器的指令集的，这样的解释引擎相较基于栈的解释引擎更高效，更节省空间，但是缺点在于基于寄存器指令集依赖硬件，无法做到跨平台，这与java跨平台的语言的设计相违背，所以jvm的解释引擎选择基于栈的指令集架构。

  栈顶缓存技术：由于使用操作数栈频繁出栈入栈消耗性能，所以将栈顶元素缓存在物理cpu的寄存器中，提升效率。



* 动态链接

* ![img](https://raw.githubusercontent.com/chen-1110/image/main/jvmimage-20220331175738692.png)

  当我们调用一个方法时，如果该方法是动态的，并不是编译期就确定的方法，这时就需要动态链接寻找该方法的引用，将常量池中的符号引用转化为直接引用。

  ~~~java
  public interface Father {
      public void test();
  }
  class Son implements Father{
  
      @Override
      public void test() {
          System.out.println("i am son");
      }
  
      public static void main(String[] args) {
          Father father=new Son();
          father.test();
      }
  }
  
  ~~~

  就比如上面的代码中，我们让一个Father类型的引用引用Son类型的对象，在执行father.test()方法时会在动态链接的引用中寻找指向常量池中该方法的符号引用，然后将符号引用转化为实际的Son类的直接引用，执行Son类的方法test（），这就是动态链接的作用。

* 方法返回地址

  在调用一个新的方法，新方法执行结束后，将继续执行上层方法，恢复上层方法的程序计数器，这时就需要新方法的方法返回地址存入程序计数器，从而继续上层方法。



​

#### 2.3.3 本地方法栈

本地方法栈与虚拟机栈类似，只是他是用来执行本地（非java）方法的，前面我们提到过，java出世之初为了支持调用c语言等其他热门的语言，设计了本地方法接口，这些方法就是在本地方法栈进行执行的，随着时代发展，现在本地方法用的也很少了，在hotspot虚拟机实现中也将本地方法栈归并入虚拟机栈，读者可以对这个结构了解即可。

#### 2.3.4 堆

1. 介绍

   堆空间存储我们创建的对象和数组实例，是垃圾回收的重点区域，是线程共享的区域。

   我想先提前讨论一下这个问题，我在写文章写到后面的标量替换的时候，忽然想到

   这里所说存储对象实例可能会让有的同学误解，那我们来谈谈对象实例是什么呢，一个类是由两个部分组成，属性和方法，但是一个对象呢，他有属性有方法，属性属于对象本身，但是方法并不属于对象，换句话说，对象实例实质上就是属性的集合（和一些其他信息），而方法的字节码作为类信息存储在方法区（后面会讲），如图5所示。

   ![对象存储图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%9B%BE.png)

   ###### 																																												图5

   ok，我们继续讲解堆空间。

2. 结构

   ![堆内存结构](https://raw.githubusercontent.com/chen-1110/image/main/hotspot-heap-structure.png)

   堆空间分成新生代，老年代，方法区三部分，但是方法区又被称为非堆区域，尤其是jdk8之后方法区也被移除了堆区域，所以一般讨论堆空间我们都是在说新生代和老年代。

   jdk7及之前永久代作为方法区的实现，在堆空间中，而在jdk8以及之后方法区的实现由永久代换成了元空间，放在了堆空间之外，如图5，这样的设计是因为随着方法区存储的内容增多很容易引起oom（out of memery)，而放在堆外很好地避免了这个问题，毕竟方法区存储的大部分信息是难以被回收的必要信息。

![第08章_方法区的演进细节-hotspot](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E7%AC%AC08%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82-hotspot.jpg)

###### 																																											图5

​	可以用类似-xms：100m设置堆空间起始内存，用类似-xmx：100m设置堆空间最大内存

5. 分代收集理论：

   如图6，堆空间有两块区域，年轻代和老年代，年轻代用来存储朝生夕死的对象，而老年代用来存储生命力比较顽强的对象，年轻代又分为eden区，survivor0区（from区），survivor1区（to区），在垃圾收集的过程中，先收集ende区，仍然存活的对象放入from区，下次收集再把eden和from区存活的对象放入to区，收集多次仍存活的对象放入old区，这样设计有利于及时回收生命周期很短的对象，高效利用内存资源。

   默认新生代和老年代大小比例为1：2，可以通过类似-XX:NewRatio=2设置大小比例

![20210903110513](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png)

###### 																																														图6

6. 对象分配过程：

   如图7，创建对象后，先看eden区是否放的下对象，如果放得下直接放到eden区，如果放不下则进行一次young gc（年轻代垃圾回收），回收之后看eden区现在是否放得下对象，如果放的下直接放到eden区，如果放不下看old区是否放的下，如果放得下就放到old区，如果放不下进行full gc（全堆垃圾回收），回收之后看old区是否放得下，如果放的下放到old区，如果放不下报错oom。

   我们接着讲一下ygc做了什么，ygc首先垃圾回收eden区和from区，看看eden区和from区存活的对象to区是否放的下，如果放不下直接放入old区，如果放得下则放入to区，之后to区和from区名字交换（谁空谁是to区），每个对象记录自己经历过ygc的次数，当次数超过阈值（默认是15）时放入old区

   可以通过类似-XX：MaxTenuringThreshold=15来设置新生代晋升老年代的阈值

![对象分配过程图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%E5%9B%BE.png)

###### 	                                                                                      																								图7

7. 几种gc：

   ygc，young gc，针对年轻代的gc，eden区空间不足时发生。

   major gc / old gc，针对老年代的gc，只有个别垃圾回收器中会有major gc，所以大多将major gc和fgc混淆使用

   fgc，full gc，针对全堆的gc，老年代，方法区空间不足时发生。

8. TLAB

   一般来说，堆内存是线程共享的区域，多个线程在给对象分配堆空间内存时要解决并发的同步安全问题导致系统性能降低，于是诞生了TLAB（Tread Local Allocation Buffer），他是给每一个线程分配极小（1%）的一块内存让线程独享，这样在对象分配时各线程可以先使用TLAB中的空间，如果不足的话再并发的分配空间（并发具体算法我不懂，等我学了再简单讲讲吧）

9. 逃逸分析

   有一类对象，他们只在当前方法使用，不会影响到其他方法，换句话说，该类对象的生命随着方法的结束而结束，逃逸分析技术可以在编译器分析出来这一类对象，即无法逃逸出当前方法的对象，对于这类对象，我们可以采取和其他对象不同的策略，从而提升系统性能。

   如图8，展示了一些逃逸对象和非逃逸对象，加深理解

   ![20210903133700](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%9B%BE1.png)

   ![20210903133708](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%9B%BE2.png)

   ###### 																																											图8

   栈上分配：对于无法逃逸的对象，可以将对象直接分配到栈上，这样随着栈帧的毁灭而毁灭，省去了垃圾回收的过程，减少堆内存，提高性能。遗憾的是，hotspot虚拟机并未采取栈上分配的策略。

   同步省略：对于无法逃逸的对象，如果一段代码块持有该对象的synchronized锁，在编译器即可自动抹去这段同步操作，代码执行过程中没有考虑并发问题，提高性能。

   标量替换：我们将对象实例存储在堆上，存储的实际上是属性的集合，如果一个对象无法逃逸出方法，我们可以将它替换成基本量的集合，作为局部变量存储在局部变量表中，这样的话就省去了垃圾回收的过程，减少堆内存，提高性能。事实上，hotspot虚拟机正是采取这样的解决方案。

   逃逸分析的优缺点：还记得我们刚才说到hotspot未采用栈上分配，事实上，即使是标量替换，hotspot也只是替换了一部分，既然逃逸分析这项技术有如此多的好处（节省堆内存，避免垃圾回收过程，减少并发的性能损耗），为什么不彻底使用这项技术呢，原因就在于，在编译器进行的逃逸分析，本身就很需要系统性能支持，很大的可能性就是逃逸分析带来的性能提升还不如进行逃逸分析的性能消耗，从而得不偿失，所以这门技术仍是在研究中的尚未成熟的技术。



#### 2.3.5 方法区

1. 介绍

   属于堆的一部分，但是又被称作非堆，前面讲过了在jdk8中已经把方法区移出堆之外，在元空间的位置实现方法区，方法区是线程共享的空间。在jdk8中方法区大小不设上限，也可以通过-XXMaxMetaspaceSize设置。

   方法区存储类相关的信息，包括类的类型信息，作用域修饰符，方法字节码等，方法区还存储静态变量和运行时常量池（jdk8之后将静态变量和字符串常量移到了堆中）。

   ###### ps. 为什么把方法区移除堆来实现？

   ###### 因为方法区大小不好把控，设置之后在堆中很容易oom，且大多是存活对象，垃圾较少，于是放在堆外对大小不做设置。

2. 运行时常量池详解

   运行时常量池是由字节码中的常量池经过类加载之后变成方法区中的运行时常量池，运行时常量池包括字面量和符号引用两类值，前者存储常量和静态变量，后者存储符号引用，即该类中方法用到的各种类引用，字段引用等。

   然而，在jdk8中，将静态变量和字符串常量（stringtable）移入堆中，运行时常量池中的字面量变成其他常量以及对堆中常量和静态变量的引用。

   ###### ps. 为什么把stringtable移入堆中？

   ###### 元空间gc频率低，string是大量创建的常量，移入堆中回收提高内存利用率。

3. 方法区的垃圾回收

   方法区垃圾回收频率很低，只有full gc的时候才会回收，主要回收的是废弃的常量以及不再使用的类型。

#### 2.3.6 直接内存

除了我们刚才讲到的区域，一些java代码可能会操作jvm之外的直接内存，例如nio的代码，这样的操作可能存在将jvm之外内存耗尽的问题，在调优过程中也要考虑是否存在这样的情况。



### 2.4 类加载子系统

#### 2.4.1介绍

上面一节我们讲述了jvm中的运行时数据区的内存结构，本章的重点已经讲完了，接下来一节是本章的次重点，我们将讲解编译好的字节码文件是怎样通过类加载子系统加载到运行时数据区的。

这里提醒一下，并不是所有的类都会在jvm启动时加载进运行时数据区，只会加载一部分核心类，其他类在遇到new等操作的时候再加载。

前面说到，字节码文件是由01组成的二进制流，类加载子系统按照一定的规则读取二进制流并把他们解析为运行时数据区，如下图所示。

![类加载过程图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%9B%BE.png)

###### 																																																	图9

接下来我们来详细地讲一下类加载过程中做了什么。

#### 2.4.2 类加载过程详解

1. 加载阶段

   读取该类的字节码文件，将该类的字节码流转化为方法区的类的数据结构，存储到方法区中，内存中形成该类的模板，作为方法区该类的数据访问入口

2. 链接阶段

   验证：检查字节码二进制流的格式是不是jvm可以解读的格式

   准备：为类变量赋值初始零值（final量除外，在编译成字节码文件时就以设置好值）

   解析：将常量池中部分符号引用转化为直接引用，记得我们前面在讲动态链接的时候就讲过将符号引用转化为直接引用，动态链接是在运行时进行这个转换，针对的时无法确定的符号引用（多态导致的），而对于可以在类加载过程中确定的符号引用就会在解析阶段转化为直接引用。

3. 初始化阶段

   进行代码中类变量的赋值操作以及静态代码块的执行，具体在字节码中表现为<client>方法，之后我们在使用jclasslib（字节码分析工具）就可以看到该方法，这里就不截图了，之后讲到字节码指令再看。

#### 2.4.3 类加载器分类

1. 介绍

   类加载器分为引导类加载器（Bootstrap ClassLoader）和用户自定义类加载器

   引导类加载器是由c语言编写的类加载器，而用户类加载器并不是指开发者自定义的类类加载器（和后面的User Defined Class Loader是两个东西），而是凡是派生ClassLoader的类加载器，是三种类加载器的统称。

2. 常见的类加载器

   ![类加载器图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9B%BE.png)

   ###### 																																												图10

   如图10所示是常见的类加载器，这里的箭头并不是继承关系，只是包含关系，除了引导类加载器之外都派生于ClassLoader，接下来我们简单介绍一下几种类加载器。

* 引导类加载器（Bootstrap Class Loader）

  c/c++编写，并不派生于ClassLoader，用来加载报名为java，javax，sun等java核心类，加载扩展类和系统引用类类加载器

* 扩展类加载器（Extension Class Loader）

  java编写，派生于ClassLoader，加载系统中一些比较核心的类，父加载器为引导类加载器

* 系统应用类加载器（System Class Loader）

  java编写，派生于ClassLoader，加载开发者自定义的类，父加载器为扩展类加载器

* 用户自定义类加载器（User Defined Class Loader）

  用户自己编码实现的类加载器

#### 2.4.4 用户自定义类加载器详解（User Defined Class Loader）

1. 为什么需要用户自定义加载器？

* 隔离加载类

  例如，再web服务器，我们可能需要一个类库的几个不同版本，此时就需要不同的类加载器来加载同一个类库的不同版本

* 修改类加载的方式

* 扩展加载源

  我们开发者自己编写的类在加载的过程中默认字节码文件是在当前项目的路径下，但是有的时候我们需要从网络流中获取字节码流，此时就需要自定义类加载器指定加载源路径

* 防止源码泄露

  有时我们需要对字节码流加密，此时就可以在类加载阶段进行解密，这时就需要自定义类加载器，从而防止源码泄露

2. 如何自定义类加载器

   继承Class Loader，然后重写loadClass（）方法或者重写findClass（）方法（loadClass（）方法默认首先尝试让父加载器尝试加载，如果无法加载调用findClass（）加载）

#### 2.4.5 双亲委派机制

~~~java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
~~~

可以看到上面代码中，递归调用parent类加载器的loadClass()方法，即先让父加载器尝试加载该类，如果父加载器无法加载再让下层类加载器加载，层层递进。

这样做的好处是避免一个类被不同的类加载器多次加载，此外，如果不采用双亲委派机制，例如用户自定义一个java.lang.String类，就可以对核心的类库进行修改，所以该机制保护了核心类库不被修改。

沙箱安全机制：jvm对于不同的类赋予不同的系统权限，例如，用户自定义的java.lang.String类便是在类加载过程中由于权限不足无法加载报错，从而保护系统资源。



#### 2.4.6 补充

1. java两个类相同的条件是，名称相同且由同一个类加载器加载

2. 之前讲过jvm启动时并不会把所有类的字节码文件都加载到运行时数据区，而在以下几种情况会进行加载。

   1）使用new关键字实例化对象的时候。
   2）读取或设置一个类型的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）
   的时候。
   3）调用一个类型的静态方法的时候。
   4） 使用java.lang.reflect包的方法对类型进行反射调用的时候， 如果类型没有进行过初始化， 则需
   要先触发其初始化。
   5） 当初始化类的时候， 如果发现其父类还没有进行过初始化， 则需要先触发其父类的初始化。
   6） 当虚拟机启动时， 用户需要指定一个要执行的主类（ 包含main()方法的那个类） ， 虚拟机会先
   初始化这个主类。
   7） 当使用JDK 7新加入的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解
   析结果为REF_getStatic、 REF_putStatic、 REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句
   柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。
   8） 当一个接口中定义了JDK 8新加入的默认方法（ 被default关键字修饰的接口方法） 时， 如果有
   这个接口的实现类发生了初始化， 那该接口要在其之前被初始化。



### 2.5 前端编译与后端编译

讲完了上一节关于类加载的过程，这一章的重点已经全部讲完了，不过还是提一下前端编译与后端编译，当然并不是说这个部分对于jvm不重要，很多大佬们在这个部分花功夫让jvm变得性能更强，只不过对于我以及初学jvm的同学们，这一部分的技术显得相当不重要了，只是了解有个印象就可以了。

我没学过编译原理，就按照我的理解大概说一下。

c/c++代码执行过程：

高级语言代码----->编译中间产物------->编译中间产物------>.......------->机器指令------>统一执行

java代码执行过程：

高级语言代码------->前端编译为字节码-------->逐条解释成机器指令，逐条执行（后端编译）

先说前端编译，前端编译将java代码变成字节码，进行这个过程的原因就是前面提到的跨语言的平台设计，忘记的可以回去看看。

再说后端编译，后端编译将字节码指令逐条执行，这在系统内存较少的嵌入式设备中可以很好地减少系统内存，此外在代码量较少时执行速度较快，但是在代码规模增大时相比较统一编译执行速度要慢很多，这也是人们长久以来java代码比c语言代码慢的印象的产生原因，不过随着jvm不断研究进步，jvm后端编译也引入了统一编译执行的方式，那就是热点探查技术，这也是hotspot虚拟机的起名原因，jvm在运行过程中对于多次执行的方法统一编译，这样下次执行时直接执行编译后的结果即可，可以有效地提高系统性能。



## 3. 字节码浅析

### 3.1 概述

这一章我们将浅析字节码，这不是我们学习jvm的重点，但是我认为这也是不可或缺的一环。

上一章我们学习jvm的内存结构，还记得我们学过前端编译是将java代码变成字节码的操作过程，相比较java代码，掌握java代码对应的字节码指令可以帮助我们更细粒度地掌控我们的代码，不过，我认为学习字节码并不是像我们学习java语言的学习语言的过程，而是类似我们上小学的时候学习新华字典的使用过程，我们不用强行记忆所有的字节码指令，只需了解字节码指令是什么样的东西并且学会根据互联网上的资料解读java指令即可，总的来说，这一章是一本字典，我们要学会的是如何查字典以及了解字典的组成，我们的讲解也会尽量的简单一些。

此外，一开始的时候我们讲过可能会遇到一些神奇的“bug”，这些“bug”也可以通过阅读字节码指令一探究竟，开篇我们挖的那个坑现在也要填一下了，给大家回忆一下，下面这段代码的运行结果为true，false

~~~java
Integer a=1;
Integer b=1;
System.out.println(a==b);
Integer c=128;
System.out.println(c==d);
~~~

这是为什么呢，按照我们的常理要么都是true，要么都是false，结果为什么不一样呢？

我们来看看这段代码的字节码指令

![奇怪bug字节码指令](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%A5%87%E6%80%AAbug%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.png)

现在看不懂没有关系，大家跟着我的思路理解一下这个过程就可以了，我们可以看到在第6行调用了Integer.valueOf(int i)方法，这对应的是java代码中Integer a=1的部分，其实就是一个自动装箱的过程，然后我们再看看Integer.valueOf(int i)方法，这是该方法的源码

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

实际上发生的事情就是在自动装箱的过程他会比较要装箱的数值，如果该数值大于等于-128，小于等于127就会在缓存中拿到该Integer类型的引用，如果不是的话就会创建Integer对象，所以当我们装箱的值为1的时候实际上拿到的是同一个引用，比较为true，当值为128的时候则是创建了两个对象，值为false。

上面只是举一个例子，类似的奇怪的“bug”在编码过程中我们还会遇到，例如i++，++i之类的，但是只要我们学会了阅读字节码指令，这些问题都会迎刃而解，所以前文中把这一章叫做字典，相信同学们能够理解我的用意吧。

### 3.2 字节码指令浅析

1. 介绍

   我们前面讲到，字节码文件实际上是由01组成的二进制流，一般来说开发人员会使用jclasslib等字节码转化工具来阅读字节码，但是实际上，只要按照字节码文件的格式去阅读二进制流也能够读取到我们想要的信息，笔者曾就跟着尚硅谷宋红康老师的视频经历过这个过程，不过我认为这样的过程确实没太大必要，感兴趣的同学们可以查阅互联网上的资料来进行这样的阅读，这里就不加叙述了。

2. 举例

   我们现在来看一看这个Animal类

   ~~~java
   public class Animal {
       private String name;
   
       public void test(){
           System.out.println("test");
       }
       public static void main(String[] args) {
           int i=10;
           System.out.println(i);
       }
   }
   ~~~

   如图11，这是通过jclasslib插件转化的Animal类的字节码文件，可以看到主要有几个部分，常量池之前讲过，存储字面量和符号引用，接口就是类实现的接口，字段和方法同学们应该能看懂，这里的<init>方法就是默认的类的空参构造方法，属性和一般信息就是一些与类相关的其他信息。

   ![jclasslib图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/jclasslib%E5%9B%BE.png)

   ###### 																																												图11

   我们也可以点进main方法，看看字节码指令写了些什么

   ![jclasslib_main方法图](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/jclasslib_main%E6%96%B9%E6%B3%95%E5%9B%BE.png)

   ######                                                                                         																				图12

   如图12所示，这里我就不解释每条指令是什么意思了，同学们已经学过一门高级语言了，可以来自己来猜一猜。

3. 字节码指令解析

   这一部分我们将引用尚硅谷宋红康老师总结的笔记，因为他写的实在是很好，我查找了市面上的资料，这是我看到关于字节码指令最好的总结，当然同学们也可以查询oracle的网站，在jclasslib中点击要查阅的指令就会自动跳转。

   下面是引用的笔记内容

   ~~~
   JVM指令手册
   
   尚硅谷Java研究院
    
    一、栈和局部变量操作
   
   ### 将常量压入栈的指令
   
   aconst_null 将null对象引用压入栈
   iconst_m1 将int类型常量-1压入栈
   iconst_0 将int类型常量0压入栈
   iconst_1 将int类型常量1压入栈
   iconst_2 将int类型常量2压入栈
   iconst_3 将int类型常量3压入栈
   iconst_4 将int类型常量4压入栈
   iconst_5 将int类型常量5压入栈
   lconst_0 将long类型常量0压入栈
   lconst_1 将long类型常量1压入栈
   fconst_0 将float类型常量0压入栈
   fconst_1 将float类型常量1压入栈
   dconst_0 将double类型常量0压入栈
   dconst_1 将double类型常量1压入栈
   bipush 将一个8位带符号整数压入栈
   sipush 将16位带符号整数压入栈
   ldc 把常量池中的项压入栈
   ldc_w 把常量池中的项压入栈（使用宽索引）
   ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）
   
   ### 从栈中的局部变量中装载值的指令
   
   iload 从局部变量中装载int类型值
   lload 从局部变量中装载long类型值
   fload 从局部变量中装载float类型值
   dload 从局部变量中装载double类型值
   aload 从局部变量中装载引用类型值（refernce）
   iload_0 从局部变量0中装载int类型值
   iload_1 从局部变量1中装载int类型值
   iload_2 从局部变量2中装载int类型值
   iload_3 从局部变量3中装载int类型值
   lload_0 从局部变量0中装载long类型值
   lload_1 从局部变量1中装载long类型值
   lload_2 从局部变量2中装载long类型值
   lload_3 从局部变量3中装载long类型值
   fload_0 从局部变量0中装载float类型值
   fload_1 从局部变量1中装载float类型值
   fload_2 从局部变量2中装载float类型值
   fload_3 从局部变量3中装载float类型值
   dload_0 从局部变量0中装载double类型值
   dload_1 从局部变量1中装载double类型值
   dload_2 从局部变量2中装载double类型值
   dload_3 从局部变量3中装载double类型值
   aload_0 从局部变量0中装载引用类型值
   aload_1 从局部变量1中装载引用类型值
   aload_2 从局部变量2中装载引用类型值
   aload_3 从局部变量3中装载引用类型值
   iaload 从数组中装载int类型值
   laload 从数组中装载long类型值
   faload 从数组中装载float类型值
   daload 从数组中装载double类型值
   aaload 从数组中装载引用类型值
   baload 从数组中装载byte类型或boolean类型值
   caload 从数组中装载char类型值
   saload 从数组中装载short类型值
   
   ### 将栈中的值存入局部变量的指令
   
   istore 将int类型值存入局部变量
   lstore 将long类型值存入局部变量
   fstore 将float类型值存入局部变量
   dstore 将double类型值存入局部变量
   astore 将将引用类型或returnAddress类型值存入局部变量
   istore_0 将int类型值存入局部变量0
   istore_1 将int类型值存入局部变量1
   istore_2 将int类型值存入局部变量2
   istore_3 将int类型值存入局部变量3
   lstore_0 将long类型值存入局部变量0
   lstore_1 将long类型值存入局部变量1
   lstore_2 将long类型值存入局部变量2
   lstore_3 将long类型值存入局部变量3
   fstore_0 将float类型值存入局部变量0
   fstore_1 将float类型值存入局部变量1
   fstore_2 将float类型值存入局部变量2
   fstore_3 将float类型值存入局部变量3
   dstore_0 将double类型值存入局部变量0
   dstore_1 将double类型值存入局部变量1
   dstore_2 将double类型值存入局部变量2
   dstore_3 将double类型值存入局部变量3
   astore_0 将引用类型或returnAddress类型值存入局部变量0
   astore_1 将引用类型或returnAddress类型值存入局部变量1
   astore_2 将引用类型或returnAddress类型值存入局部变量2
   astore_3 将引用类型或returnAddress类型值存入局部变量3
   iastore 将int类型值存入数组中
   lastore 将long类型值存入数组中
   fastore 将float类型值存入数组中
   dastore 将double类型值存入数组中
   aastore 将引用类型值存入数组中
   bastore 将byte类型或者boolean类型值存入数组中
   castore 将char类型值存入数组中
   sastore 将short类型值存入数组中
   wide指令
   wide 使用附加字节扩展局部变量索引
   
   ### 通用(无类型）栈操作
   
   nop 不做任何操作
   pop 弹出栈顶端一个字长的内容
   pop2 弹出栈顶端两个字长的内容
   dup 复制栈顶部一个字长内容
   dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈
   dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈
   dup2 复制栈顶部两个字长内容
   dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈
   dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈
   swap 交换栈顶部两个字长内容
   
   二、类型转换
   
   i2l 把int类型的数据转化为long类型
   i2f 把int类型的数据转化为float类型
   i2d 把int类型的数据转化为double类型
   l2i 把long类型的数据转化为int类型
   l2f 把long类型的数据转化为float类型
   l2d 把long类型的数据转化为double类型
   f2i 把float类型的数据转化为int类型
   f2l 把float类型的数据转化为long类型
   f2d 把float类型的数据转化为double类型
   d2i 把double类型的数据转化为int类型
   d2l 把double类型的数据转化为long类型
   d2f 把double类型的数据转化为float类型
   i2b 把int类型的数据转化为byte类型
   i2c 把int类型的数据转化为char类型
   i2s 把int类型的数据转化为short类型
   
   三、整数运算
   
   iadd 执行int类型的加法
   ladd 执行long类型的加法
   isub 执行int类型的减法
   lsub 执行long类型的减法
   imul 执行int类型的乘法
   lmul 执行long类型的乘法
   idiv 执行int类型的除法
   ldiv 执行long类型的除法
   irem 计算int类型除法的余数
   lrem 计算long类型除法的余数
   ineg 对一个int类型值进行取反操作
   lneg 对一个long类型值进行取反操作
   iinc 把一个常量值加到一个int类型的局部变量上
   
   四、逻辑运算
   
   ### 移位操作
   
   ishl 执行int类型的向左移位操作
   lshl 执行long类型的向左移位操作
   ishr 执行int类型的向右移位操作
   lshr 执行long类型的向右移位操作
   iushr 执行int类型的向右逻辑移位操作
   lushr 执行long类型的向右逻辑移位操作
   
   ### 按位布尔运算
   
   iand 对int类型值进行“逻辑与”操作
   land 对long类型值进行“逻辑与”操作
   ior 对int类型值进行“逻辑或”操作
   lor 对long类型值进行“逻辑或”操作
   ixor 对int类型值进行“逻辑异或”操作
   lxor 对long类型值进行“逻辑异或”操作
   
   ### 浮点运算
   
   fadd 执行float类型的加法
   dadd 执行double类型的加法
   fsub 执行float类型的减法
   dsub 执行double类型的减法
   fmul 执行float类型的乘法
   dmul 执行double类型的乘法
   fdiv 执行float类型的除法
   ddiv 执行double类型的除法
   frem 计算float类型除法的余数
   drem 计算double类型除法的余数
   fneg 将一个float类型的数值取反
   dneg 将一个double类型的数值取反
   
   五、对象和数组
   
   ### 对象操作指令
   
   new 创建一个新对象
   checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常
   getfield 从对象中获取字段
   putfield 设置对象中字段的值
   getstatic 从类中获取静态字段
   putstatic 设置类中静态字段的值
   instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0
   
   ### 数组操作指令
   
   newarray 分配数据成员类型为基本上数据类型的新数组
   anewarray 分配数据成员类型为引用类型的新数组
   arraylength 获取数组长度
   multianewarray 分配新的多维数组
   
   六、控制流
   
   ### 条件分支指令
   
   ifeq 如果等于0，则跳转
   ifne 如果不等于0，则跳转
   iflt 如果小于0，则跳转
   ifge 如果大于等于0，则跳转
   ifgt 如果大于0，则跳转
   ifle 如果小于等于0，则跳转
   if_icmpcq 如果两个int值相等，则跳转
   if_icmpne 如果两个int类型值不相等，则跳转
   if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转
   if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转
   if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转
   if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转
   ifnull 如果等于null，则跳转
   ifnonnull 如果不等于null，则跳转
   if_acmpeq 如果两个对象引用相等，则跳转
   if_acmpnc 如果两个对象引用不相等，则跳转
   
   ### 比较指令
   
   lcmp 比较long类型值
   fcmpl 比较float类型值（当遇到NaN时，返回-1）
   fcmpg 比较float类型值（当遇到NaN时，返回1）
   dcmpl 比较double类型值（当遇到NaN时，返回-1）
   dcmpg 比较double类型值（当遇到NaN时，返回1）
   
   ### 无条件转移指令
   
   goto 无条件跳转
   goto_w 无条件跳转（宽索引）
   
   ### 表跳转指令
   
   tableswitch 通过索引访问跳转表，并跳转
   lookupswitch 通过键值匹配访问跳转表，并执行跳转操作
   
   ### 异常
   
   athrow 抛出异常或错误。将栈顶异常抛出
   finally子句
   jsr 跳转到子例程
   jsr_w 跳转到子例程（宽索引）
   rct 从子例程返回
   
   七、方法调用与返回
   
   ### 方法调用指令
   
   invokcvirtual 运行时按照对象的类来调用实例方法
   invokespecial 根据编译时类型来调用实例方法
   invokestatic 调用类（静态）方法
   invokcinterface 调用接口方法
   
   ### 方法返回指令
   
   ireturn 从方法中返回int类型的数据
   lreturn 从方法中返回long类型的数据
   freturn 从方法中返回float类型的数据
   dreturn 从方法中返回double类型的数据
   areturn 从方法中返回引用类型的数据
   return 从方法中返回，返回值为void
   
   ### 线程同步
   
   montiorenter 进入并获取对象监视器。即：为栈顶对象加锁
   monitorexit 释放并退出对象监视器。即：为栈顶对象解锁
   
   八、JVM指令助记符
   
   变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_
   操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_
   常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_
   加：iadd,ladd,fadd,dadd
   减：isub,lsub,fsub,dsub
   乘：imul,lmul,fmul,dmul
   除：idiv,ldiv,fdiv,ddiv
   余数：irem,lrem,frem,drem
   取负：ineg,lneg,fneg,dneg
   移位：ishl,lshr,iushr,lshl,lshr,lushr
   按位或：ior,lor
   按位与：iand,land
   按位异或：ixor,lxor
   类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)
   i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)
   创建类实便：new
   创建新数组：newarray,anewarray,multianwarray
   访问类的域和类实例域：getfield,putfield,getstatic,putstatic
   把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload
   从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore
   获取数组长度：arraylength
   检相类实例或数组属性：instanceof,checkcast
   操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap
   有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,
   if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl
   fcmpg,dcmpl,dcmpg
   复合条件转移：tableswitch,lookupswitch
   无条件转移：goto,goto_w,jsr,jsr_w,ret
   调度对象的实便方法：invokevirtual
   调用由接口实现的方法：invokeinterface
   调用需要特殊处理的实例方法：invokespecial
   调用命名类中的静态方法：invokestatic
   方法返回：ireturn,lreturn,freturn,dreturn,areturn,return
   异常：athrow
   finally关键字的实现使用：jsr,jsr_w,ret
   ~~~



## 4. 垃圾回收和垃圾回收器的选择

### 4.1 概述

这一章我们将讲解jvm中的垃圾回收算法以及几种常见的垃圾回收器，我们先阐述一下垃圾回收算法和垃圾回收器的关系，我们有多种垃圾回收算法以及多种垃圾回收器，但是一个jvm只能选择一套垃圾回收器，而一般来说一套垃圾回收器会用到多种垃圾回收算法，不同的垃圾回收器使用的垃圾回收算法也有所不同。影响jvm性能的因素有很多，但是我们java开发者能够直接控制的影响性能的因素主要是两点，一个是不同内存大小的设置，再一个就是选择合适的垃圾回收器，而内存大小如何设置也和我们选择的垃圾回收器息息相关，所以垃圾回收这一章节也是我们学习的重点。

### 4.2 垃圾回收算法

#### 4.2.1 什么是垃圾

要讨论垃圾回收，先得定义什么是垃圾，垃圾是指在运行程序时没有任何指针指向的对象。

#### 4.2.2 垃圾标记阶段

1. 垃圾标记算法

* 引用计数法

  每个对象维护一个int型的数值，记录被多少对象引用，如果这个数值变成了0，则认为是垃圾可以回收

  但是引用计数法有一个致命的问题，可能会产生循环引用，导致本应该算做垃圾的对象无法回收

  ![对象之间循环引用](https://raw.githubusercontent.com/chen-1110/image/main/object-circular-reference.png)

  ###### 																																									图13

  ​	如图13所示，这样就会导致本来应该回收的三个对象循环引用从而无法回收，也正是因为这个问题，jvm并	没有采用引用计数法来判断垃圾，而是采用下面讲的这个算法

* 可达性分析算法

  ![可达性分析算法](https://raw.githubusercontent.com/chen-1110/image/main/jvm-gc-roots.png)

  可达性分析算法是指，将一组对象定义为根节点（gc roots），然后凡是能通过这些根节点对象访问到的对象都是存活对象，其他为垃圾。

  在Java技术体系里面， 固定可作为GC Roots的对象包括以下几种：

    * 在虚拟机栈（栈帧中的本地变量表） 中引用的对象， 譬如各个线程被调用的方法堆栈中使用到的
      参数、 局部变量、 临时变量等。
      ·在方法区中类静态属性引用的对象， 譬如Java类的引用类型静态变量。
      ·在方法区中常量引用的对象， 譬如字符串常量池（String Table） 里的引用。

    * 在本地方法栈中JNI（即通常所说的Native方法） 引用的对象。
    * Java虚拟机内部的引用， 如基本数据类型对应的Class对象， 一些常驻的异常对象（比如
      NullPointExcepiton、 OutOfMemoryError） 等， 还有系统类加载器。
    * 所有被同步锁（synchronized关键字） 持有的对象。
    * 反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等。

  在进行可达性分析的时候，用户线程必须终止，等可达性分析结束才能继续，这个过程叫做stw（stop the world)，这个阶段是十分影响用户体验的，所以好的垃圾回收器应该考虑如何优化这个问题。

2. 标记为垃圾一定会被回收吗？

   jvm的对象具有finalization机制，即有一个方法为Object类中有一个finalize（）方法，在被标记为垃圾后，在垃圾回收的时候会执行一次finalize（）方法，默认情况下不会进行任何操作，不过用户可以重写这个方法，在方法中加入一些操作让根节点可达该对象，从而让对象复活，这样就不会回收该对象，不过这样的操作只允许一次，如果一段时间后该对象又被判定为垃圾则无法复活。

#### 4.2.2 垃圾清除阶段

在标记好垃圾之后，就会进行垃圾清除阶段，之前我们在讲解堆内存结构时讲到了分代收集理论，这里讲解垃圾清除阶段希望读者脑袋里不要带东西，把之前讲的分代收集什么的东西都先忘掉，我们现在的关注点只在于，内存中有一块区域是垃圾，我们要清除它，怎么来操作呢？接下来来讲解几种垃圾清除算法。

* 标记清除算法

  内存中有一块区域，我们已经标记了哪些是垃圾，然后把垃圾所在的区域清除就好了

  问题：清除之后内存不规整，需要维护一个列表记录哪些地方是空闲区域

* 复制算法

  把内存划分为同样大小的的两块，每次只用一块，垃圾标记完成后把非垃圾全部转移到另一块内存，下次也进行同样的操作

  问题：内存只利用了一半，有点浪费

* 标记压缩算法

  内存中有一块区域，我们已经标记了哪些是垃圾，把垃圾所在区域清除掉之后还要把清楚之后不规整的内存整理到一起，变成一整块的内存块（所以有时也叫做标记整理算法），下次给对象分配空间的时候直接在空闲区域划过来一块就行了，不用维护空闲列表。这样的内存分配方式叫做指针碰撞，分配时直接移动记录内存使用了多少的指针就可以了。

  问题：要清除，还要整理，操作多了就会慢。

垃圾清除阶段也是需要stw的，jvm开发者对于这里的解释是，就好像妈妈收拾房间的时候你需要乖乖地呆着，而不能同时再制造垃圾，不然妈妈会揍你的，不过其实同学们可以想一想，垃圾清除阶段stw是必须的吗，恐怕不是吧，只是如果垃圾清除的同时用户进程继续操作需要重新考虑一些问题，重新设计改造原有的垃圾回收算法，事实上，在jdk不断发布的新版本中就对于垃圾清除算法进行了一些改造，从而减少stw的时间，带来更好的用户体验。（后面我们会详细地讲这个问题）

因为垃圾清除阶段需要stw，所以考虑垃圾回收算法的时候也要考虑这个因素，不然你总不会希望使用网站的时候每使用几天就要停机等待垃圾清除几个小时吧😂

![垃圾清除算法比较](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png)

###### 																				     																									图14

#### 4.2.3 分代收集理论详解

刚才我们学习了如何标记垃圾以及怎么清除垃圾，现在要讲解垃圾收集领域一个很重要的理论：分代收集理论，之前我们在讲解堆空间的时候提到过这个理论，现在我们再详细地讲述一下这个理论。

分代收集理论基于两条假说

* 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的。
* 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡。

现代的垃圾回收器在设计上都基于这两条假说，同学们回忆一下我们之前讲过的堆空间分代收集的过程，将堆内存分成了不同的区域，把新对象放在eden区，对象收集之后扔存活的放在survivor区，当对象经历过多次收集就晋升到老年代（survivor区分成from区和to区就是复制算法的体现）。为什么要这样设计呢，这样的设计保证了我们收集朝生夕死的对象的频率远大于收集难以消亡的对象的频率，因为垃圾收集器ygc的频率远小于fgc的频率，从而有效地利用堆空间内存，减少性能损耗。

不过我们刚才讲的分代收集理论是存在一个很大的问题的，可能很多读者在第一次学习jvm的时候并没有注意到这个问题，问题就在于，我们在进行ygc的时候，在垃圾标记阶段我们使用可达性分析算法实际上扫描了堆空间的所有区域，我们只希望收集新生代的垃圾，但是却扫描了所有区域，这会产生很大的stw时间，这样的设计在堆内存不断增大的过程中是一个很糟糕的问题，难道随着我们硬件的进步我们的虚拟机会定时卡顿的时间持续增大？有没有更好的方案呢，当然是有的，这就引出了第三条假说

* 跨代引用假说（ Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

基于第三条假说，jvm在对于可达性分析算法进行了一定的改进，在我们对于特定区域收集的时候，如果从gc roots可达性分析的时候到达了不同的区域，便对这条可达性路径进行剪枝（停止该路径可达性分析），为什么要做这样的设计呢，我们用ygc来举例子，ygc时，我们进行可达性分析的目的是判断新生代的对象们的死活，而当我们从gc roots到达了old区时，根据跨代引用假说，我们到达old区之后在接下来的可达性分析过程中，回到young区的可能性是极小的，绝大部分的这种到达了old区的可达性分析在接下来可达性分析的过程中始终在old区游走，那么这样的性能消耗是极大的，所以jvm对于这样的路径进行了剪枝，那么很多同学就会有问题，那对于新生代被跨代引用的对象，我们应该怎么判断它是否是垃圾呢，jvm开发者选择将凡是被跨代引用的对象都加入到gc roots中，这样的话即是认为被跨代引用的对象都是存活的对象，这样有问题吗，当然是有问题的，一定有一些跨代引用，引用者就是死亡的垃圾对象，不过记住我们说的跨代引用假说：跨代引用对于同代引用来说仅占极少数，这样的话只是有极少的一部分的垃圾被我们误判为存活对象，相比较剪枝带来的性能提升，jvm认了。

不过每个对象是如何知道谁跨代引用了他呢，这就涉及到分代收集理论中的一个结构：记忆集，每个分代区域会维护一个记录被谁跨代引用的数据结构，这就是记忆集，在jvm中，记忆集的具体实现方式叫做卡表，它记录了被哪些分区的老年代所引用（g1垃圾回收器的实现）

随着代码的运行，记忆集会改变，而要维护这样的记忆集，采用的是写屏障（具体是写后屏障）来实现，在进行引用赋值之后，会类似aop的操作一样通过写后屏障更新卡表，从而对记忆集进行维护。

#### 4.3 垃圾回收几个重要概念

1. OopMap

   我们都知道在可达性分析时首先要获取gc roots，最笨的方法就是在局部变量表和方法区等地方遍历所有变量看哪些属于对象，jvm采取了一个更好的方式，维护一个OopMap，里面记录了所有可以作为gc roots的变量的位置，这样的话在可达性分析的时候就可以节省很多时间，提升用户体验

2. 安全点

   程序执行时并不是所有时候都可以gc，只有在一系列引用状态改变很少的地方才会进行gc，这样的地方叫做安全点，同样的oopMap也是在每一个安全点进行维护一次（因为如果每条语句都要维护OopMap太浪费性能了）

   对于安全点， 另外一个需要考虑的问题是， 如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程） 都跑到最近的安全点， 然后停顿下来。 这里有两种方案可供选择： 抢先式中断（Preemptive Suspension） 和主动式中断（Voluntary Suspension）

   抢先式中断不需要线程的执行代码主动去配合， 在垃圾收集发生时， 系统首先把所有用户线程全部中断， 如果发现有用户线程中断的地方不在安全点上， 就恢复这条线程执行， 让它一会再重新中断， 直到跑到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。

   而主动式中断的思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一
   个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最
   近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的， 另外还要加上所有创建对象和其他
   需要在Java堆上分配内存的地方， 这是为了检查是否即将要发生垃圾收集， 避免没有足够内存分配新
   对象。  hotspot采用的就是主动式中断。

3. 安全区域

   安全点还存在一个问题，如果一个线程进行了sleep操作，可能sleep时它并不在安全点上，那么所有线程都要等待该线程sleep结束才能进行gc，这样的设计未免匪夷所思，于是相应的改进便是引入了安全区域，将一定范围内引用关系改变较少的代码片段划分为安全区域，而线程sleep这样的操作肯定是属于安全区域的，这样的话就避免了上述问题。

4. 内存溢出和内存泄漏

   内存溢出：jvm中的堆空间或者方法区满了，或者是直接内存满了，就会报错OOM（out of memory）

   内存泄漏：一些本应该被及时回收的类长期被gc roots持有引用，导致无法回收，比如大对象被静态变量或				   final长期持有不该有的引用，比如socket，io等连接一直没关闭。

5. 垃圾回收的并发与并行

   这一部分我们下一节会重点讲，现在先简单说一下，绿色是用户线程，红色是垃圾收集线程，下面图15就是串行，并行和并发的区别，看图应该就理解了。

   ![20210904170327](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C.png)

   ​																		![20210904170346](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%B9%B6%E5%8F%91.png)

   ###### 																						     																																														 图15

#### 4.4 垃圾回收器详解

这一节我们将讲解jvm长久地发展以来用到的垃圾回收器，对我们java程序员来说，这一部分也是与我们能进行的jvm调优最直接相关的部分之一。

讲这一章的时候我没有介绍那一节是重点哪一节不重要，因为我觉得这一章都是重点。

不过这一节对于革命性地zgc垃圾回收器这里并没有讲解，主要原因有两点，第一，zgc虽然在jdk15中从试验阶段转变为正式使用阶段，可以预见到在将来zgc一定是jvm的默认垃圾回收器，但是仍然不是默认的垃圾回收器，笔者想要等到zgc成为默认垃圾回收器之后再花费时间成本来研究其内部实现。第二，互联网上关于zgc的资料太少了，笔者水平不足自己研究不清楚这东西。

#### 4.4.1 垃圾回收器分类

按照工作模式分：串行，并行，并发

按照收集区域分：新生代垃圾回收器，老年代垃圾回收器

#### 4.4.2 垃圾收集器的性能指标

吞吐量：用户线程运行时间占总时间的比例，（约）等于用户线程时间 / (用户线程时间+垃圾回收时间)，对于一			   些不强调用户交互的任务（如大规模计算型），吞吐量是最重要的指标。

暂停时间：垃圾回收时需要stw的时间，对于强调用户交互的任务（如聊天网站），暂停时间是最重要的指标

内存占用：java堆内存可以使用的空间，不同垃圾回收器对于空间处理方式不一样（比如如果只使用复制算法的垃				  圾回收器内存空间只能有效利用一半），不过随着硬件的升级，内存占用越来越变成不太重要的指标，				  最重要的指标是上面提到的两个指标

#### 4.4.3 常见垃圾回收器概述

这里简单地介绍一下几种常见的垃圾回收器，下一部分会详细介绍这几种垃圾回收器

这里我直接贴尚硅谷宋红康老师的图了，同学们可以看一下图片内容，简单直接。

![垃圾回收器历史](D:\新桌面\博客\jvm\图片\垃圾回收器历史.png)

![垃圾回收器按工作模式分类](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%8C%89%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB.png)

![垃圾回收器按收集区域分类](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%8C%89%E6%94%B6%E9%9B%86%E5%8C%BA%E5%9F%9F%E5%88%86%E7%B1%BB.png)

![垃圾回收器组合](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88.png)

![垃圾回收器组合详解](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88%E8%AF%A6%E8%A7%A3.png)

可以用-XX：+PrintCommandLineFlags查看命令行参数（其中包含垃圾回收器使用情况）

#### 4.4.4 常见垃圾回收器详解

##### 4.4.4.1 Serial回收器

![Serial 收集器](https://raw.githubusercontent.com/chen-1110/image/main/serial-garbage-collector.png)

新生代回收器，串行

hotspot默认client模式垃圾回收器（我们使用的都是client模式）

适合单核cpu，在单核情况下简单高效

默认和老年代回收器Serial Old回收器搭配使用

使用复制算法（凡是新生代分eden区，survivor区使用的都是复制算法）

使用-XX：+UseSeriaGC指定使用

适合于简单小型的桌面应用，不适合现在的java网站

##### 4.4.4.2 ParNew回收器

与Serial十分相似，只不过改成了并行

新生代收集器

是很多情况下jvm server模式下的默认回收器

无法和Parallel Old老年代回收器搭配使用（历史原因，框架不兼容，非技术问题）

现在只能和CMS老年代回收器搭配使用

使用-XX:+UseParNewGC指定使用，-XX:ParallelGCThreads指定线程数量

##### 4.4.4.3 Parallel回收器

![Parallel Old收集器运行示意图](https://raw.githubusercontent.com/chen-1110/image/main/parallel-scavenge-garbage-collector.png)

与ParNew也十分类似，区别在于这是一款可控制吞吐量的垃圾回收器，可以通过设置的吞吐量目标自适应调节（调节内存空间分配等），所以也被称为吞吐量优先的垃圾收集器。

jdk6以前是和serial old老年代回收器搭配，jdk6之后改成了Parallel Old老年代回收器搭配

也是jdk8默认的新生代垃圾回收器

在吞吐量优先的场景中Parallel和Parallel Old的组合效果相当不错

-XX：+UseParallelGC 开启

-XX:ParallelGCThreads 设置线程数

-XX:MaxGCPauseMillis 设置stw最大时间

-XX:GCTimeRatio 设置用户线程运行时间占总时间比例，默认99

-XX:+UseAdaptiveSizePolicy 开启自适应调节模式

##### 4.4.4.4 Serial Old回收器

老年代收集器，串行，采用标记压缩算法

##### 4.4.4.5 Parallel Old回收器

老年代收集器，并行，采用标记压缩算法

##### 4.4.4.6 CMS回收器

![CMS 收集器](https://raw.githubusercontent.com/chen-1110/image/main/cms-garbage-collector.png)

1. 概述

   并发收集器（实际上也是需要stw一段时间，但是相比较之前的收集器有并发执行的过程）

   低延迟（因为是并发收集器）

   老年代收集器

   和Parallel收集器搭配使用

   采用标记清除算法

   缺点是并发阶段用户线程的性能会降低，此外由于存在并发阶段，一边清理一边分配对象，对于堆空间的清理不能等到堆快要满才清理，而要预留一些空间，当cms在并发清理阶段堆内存将要溢出时，会采用serial old收集器串行清理。

2. **CMS收集过程详解**

   cms收集整体上分为四个阶段，即初始标记阶段，并发标记阶段，重新标记阶段，并发清除阶段，如图16所示

   ![cms收集过程](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/cms%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B.png)

   ###### 																																																																					图16

    * 初始标记

      标记所有gc roots能直接关联的对象，需要stw，因为直接关联对象比较少，所以stw时间很短

    * 并发标记

      从刚才标记的直接关联的对象开始遍历整个堆空间（别忘了跨代要剪枝哦），耗时较长，但是不需要停顿用户线程，和垃圾回收线程并发运行。

    * 重新标记

      刚才并发标记因为并发标错了一些对象，现在重新修正（之后会详解标错了什么以及怎么修正）,需要stw，但是相比较以前的垃圾回收器长时间stw要好很多。

        * 并发清除、

      清除垃圾，因为用的是标记清除算法，所以可以和用户线程并发执行(算是填了之前垃圾清除阶段挖的坑)

      ps. 如果用的是标记压缩算法就不能并发执行了，因为压缩过程会和对象分配过程冲突，不过这并不是不可能的，如果重新设计标记压缩算法我相信一定也可以并发执行的。

   正是因为stw只发生在初始标记和重新标记阶段，所以称其为低延迟的收集器

   接下来我们花较大的篇幅来讲解一下并发标记标错了哪些东西，以及如何修正，我们把这一节起名为并发的可达性分析。

3. **并发的可达性分析**

   我们先来思考一下并发标记阶段会出现哪些问题

    * 将垃圾标记成存活对象

      ![image-20251127191948602](https://raw.githubusercontent.com/chen-1110/image/main/image-20251127191948602.png)

      这个问题为什么会出现呢，其实很简单，在可达性分析时，一个对象被根节点链所引用着，将它标记为存活对象，然后之后用户线程将这个引用置为null，该对象就变成了垃圾，对于这种情况cms收集器选择不处理，毕竟这一部分垃圾是可以接受的，这一部分浮动垃圾会在下次gc时被清理。

    * 将存活对象标记为垃圾

      ![image-20251127192014729](https://raw.githubusercontent.com/chen-1110/image/main/image-20251127192014729.png)

      先不说这个问题是怎么产生的，首先要说的是上一个问题cms收集器选择不处理，这个问题可以不处理吗？答案肯定是不行的，别人好好的正在使用的对象你给人回收了那不成严重生产事故了，所以这个问题是一定要处理的。

      接下来我们继续说这个问题是怎么产生的，在并发标记阶段，有三个对象，一个已经被扫描过了是存活对象，我们姑且称其为1号对象，另一个也扫描过了是存活对象，正在扫描这个对象引用了哪些对象，我们姑且称其为2号对象，还有一个对象被2号对象引用，我们姑且称其为3号对象，这个时候，用户将2号对象对3号对象的引用置为空，然后将1号对象引用3号对象，按理来说此时3号对象仍是存活对象，但是由于1号对象已经扫描过了，此时正在扫描的是2号对象引用了哪些对象，所以就会认为3号对象是垃圾，从而将3号对象标记为了垃圾。

      上面是这个问题的文字讲解，我们可以看看很有名的对于这个问题的阐述图，即三色标记图。

      如图16所示

      白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。
      黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。
      灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。



     这种问题要怎样解决呢？

     Wilson于1994年在理论上证明了， 当且仅当以下两个条件同时满足时， 会产生“对象消失”的问
     题， 即原本应该是黑色的对象被误标为白色：

     * 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
     * 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。  

     所以要解决这个问题，只需要把这两个条件打破其中一个即可，而对应的两种解决算法便是对应打破其中一个条件的算法，他们分别是增量更新算法和原始快照算法。

     * 增量更新算法（CMS）

       破坏第一个条件，即，每当黑色对象建立新的引用时，就将黑色对象记录下来，在重新标记阶段将这些记录下来的对象作为灰色对象重新可达性分析，具体是使用写后屏障实现。

     * 原始快照算法（G1）

       破坏第二个条件，即，每当删除了灰色对象的引用，便将这个引用的白色对象记录下来，在重新标记阶段将这些记录下来的对象作为灰色对象重新可达性分析，具体是使用写前屏障实现。

     cms中采用增量更新算法，后面要讲的g1收集器则采用原始快照算法，原始快照算法由于省去了黑色对象重新可达性分析的过程而是直接从白色对象进行可达性分析，效率会比增量更新算法快很多，尤其是在g1这样的分区收集器中，不过同样的由于默认将白色对象视作重新标记的gc roots，产生的浮动垃圾会更多。

4. cms的弊端

   会产生内存碎片，并发过程用户线程性能会急剧下降，浮动垃圾较多可能会导致full gc

5. cms参数设置

   -XX:+UseConcMarkSweepGC 使用cms

   -XX:CMSlnitiatingOccupanyFraction 设置堆内存到达多少的阈值时进行major gc，如果内存使用快可以适当降低该值，内存使用慢可适当增加该值

   -XX:CMSFullFCsBeforeCompaction 设置进行多少次full gc后进行内存压缩整理（整理成规整的内存）

   -XX:ParallelCMSThreads 设置垃圾回收线程数



##### 4.4.4.7 g1回收器

![img](https://raw.githubusercontent.com/chen-1110/image/main/gc-collector-20231228213824.png)

![G1 收集器](https://raw.githubusercontent.com/chen-1110/image/main/g1-garbage-collector.png)

1. 全堆收集器，包括ygc，mixed gc，fgc

2. 针对多核cpu和大容量内存的大型机器

3. jdk9至今的默认垃圾回收器

4. garbage first垃圾回收器，侧重点收集垃圾最大量的区间

5. 分区收集，将内存分成一个个大小相同的region，如图17，18所示

![20210904230427](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E6%8A%9B%E5%BC%83%E4%BC%A0%E7%BB%9F%E5%88%86%E4%BB%A3.png)

###### 																					      																					图17

![20210904230435](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E6%8B%A5%E6%8A%B1g1%E6%96%B0%E7%9A%84%E5%88%86%E4%BB%A3.png)

###### 																																												图18

5. 由于分成了很多的region，收集过程中region之间是复制算法，但是整体内存上时标记压缩算法

6. 由于将内存分成了很多region，收集的过程中可以只选取部分的region进行收集（并且优先收集垃圾比例大的区域），所以g1也被称为具有可预测的停顿时间模型，可以设置垃圾回收的时间不超过N毫秒。

7. -XX:+UseG1GC  启用g1回收器

   -XX:G1HeapRegionSize 设置每个region的大小

   -XX:MaxGCPauseMillis  设置最大gc停顿时间

8. g1设计的原则是简化jvm调优，开发人员只需完成三步：

   第一步，开启g1

   第二步，设置堆的最大内存

   第三步，设置最大的停顿时间



9. 在以下情况使用g1可能会比使用cms效率更高：

    * 超过50%的堆空间被活动数据占用
    * 对象分配或者年代提升频率很高
    * gc时间过长

10. 每一个region肯定是eden，survivor，old，humongous的一种，这里的humongous是用来分配大对象专有的一块region空间（大于1.5倍region的对象），但是每一个region的身份不一定，可能现在是old区，下次垃圾收集后就变成了eden区

11. 每一个region内也是用指针碰撞来存放数据（之前讲标记压缩算法讲过，忘记的可以翻回去看看），同时也存在TLAB的空间（之前在讲堆内存讲过）

12. g1垃圾回收过程

    主要包括以下四个环节

    * ygc

      独占式的并行垃圾回收

      具体步骤：

        * 扫描gc roots

        * 更新记忆集

          为什么要在这时候更新记忆集呢，前面我们讲过可以通过写屏障直接直接更新卡表，但是这样的操作需要线程同步浪费性能，不如直接放到队列中在ygc stw的时间中去更新，而且g1回收器中的记忆集是双向的，记录引用了谁也记录谁引用了我。

        * 处理记忆集

          识别跨代引用，从而更新正确的gc roots

        * 复制对象

          可达性分析扫描，就像之前讲的年轻代垃圾收集一样使用复制算法进行收集

        * 处理引用

          处理一些虚引用等,以便完全清理eden区

    * 老年代并发标记

      当堆内存使用到达阈值（默认45%）时，进行老年代并发标记过程，并发标记过程中同时ygc也会随着eden空间不足而进行，互不干扰。

      具体步骤：

        * 标记从根节点可达的对象

          stw，并且会触发一次ygc（为什么会触发ygc呢，因为想利用ygc的stw时间进行标记）

        * 根区域扫描

          扫描survivor区的直接可达的老年代对象，这里有一个疑惑，既然记忆集是双向记录，为什么还需要扫描呢，这是因为记忆集不会记录从新生代出发的指针，所以需要这个扫描过程，刚才完成的ygc将对象放入了survivor区，所以只扫描survivor即可，并且这次扫描结束之前不能进行下一次ygc（因为下次ygc会移动survivor区）

        * 并发标记

          标记过程中如果发现某个region全是垃圾会立即清理

        * 再次标记

          修正之前的标记的错误，即前面讲到的原始快照算法

        * 独占清理

          stw，计算各region中垃圾和总空间的比例，并排序，并不会真正的清理

        * 并发清理

          清理完全是垃圾的region

    * mixed gc

      标记阶段结束后就会进行混合回收，回收过程会把老年代的region分8段回收，每次先回收垃圾多的部分，回收集是1/8的老年代对象以及年轻代对象，回收方式与年轻代回收相同

    * 前面gc失败，进行单线程，独占式的full gc

      导致full gc的原因有

        * 没有to空间放晋升对象（增大堆空间）
        * 并发收集结束前空间耗尽（降低开始并发标记的阈值）
        * 最大gc停顿时间设置太短，导致没法在规定时间完成垃圾回收（增加最大gc停顿时间）

13. g1使用建议

    * 避免自行设置年轻代大小
    * 吞吐量要求不要太严苛

#### 4.4.5 垃圾回收器总结

![20210905010441](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png)

![20210905010637](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%80%89%E6%8B%A9.png)



## 5. 调优工具介绍

### 5.1 概述

终于完成了对于垃圾回收算法的学习，我们已经武器库里面现在终于拥有了jvm这把利刃，接下来我们要做的就是将知识转化为实战，这一章我们将先大概讲解一下调优要做些什么，然后简单说几款调优工具，之后阅读深入理解jvm中几个调优的例子，这一章并不是我们学习的重点，因为我认为真正的调优进步一定是在大量实战中进行的，不过我们可以先学习一些调优的理论知识。

这是我们进行调优的步骤：

![20210905012201](https://hc-czw-bucket.oss-cn-beijing.aliyuncs.com/jvm/%E5%9B%BE%E7%89%87/20210905012201.png)



### 5.2 重要jvm指令

```
# 设置堆内存初始和最大大小
-Xms4G -Xmx4G
# --- 推荐的基础配置 ---
# 打印详细 GC 信息
-XX:+PrintGCDetails
# 打印 GC 发生的时间戳 (相对于 JVM 启动时间)
# -XX:+PrintGCTimeStamps
# 打印 GC 发生的日期和时间 (更常用)
-XX:+PrintGCDateStamps

```



### 5.2 调优工具介绍

1. 命令行指令

   jstat查看jvm信息

   jinfo查看和修改jvm参数

   jmap导出内存映像dump文件

   jhat可以对堆进行分析

   jstack可以查看线程快照

   jcmd多功能

   jstatd远程操作

2. GUI

   Visual VM 很好用的gui

   JProfiler 收费，但是特别好用

   Arthas 阿里产品，无需远程连接，直接在服务器上运行查看

上面提到了几款gui以及命令行指令，并没有详细介绍这些工具，笔者觉得最好的方式还是读者自己下载下来实际使用能够更好地学习这几款工具，这里只是简单介绍，自己用了才自己清除，调优工具不需要样样精通，有一款自己喜欢的熟练就好了。



### 5.3 几个关于调优的实例

笔者本来想这一部分来截图来给各位展现我觉得不错的调优实例，不过觉得阅读经典书籍恐怕是一个更好的方式，关于调优实例，同学们可以看深入理解java虚拟机第五章的内容，笔者看了之后觉得大有收获，也强烈建议学习的同学们也看一下这一部分。





## 6.结语

不知不觉已经23000余字，本来想着一天写好的最终花费了四五天的时间，现在已经是深夜两点在兴奋中终于写完了这篇博客，在编写的过程中查阅了大量的资料也学到了很多东西，希望我和诸君继续加油，在技术的路上越走越远。

写博客不易，如果帮助到某位同学，希望能给我的github一个star鼓励鼓励，[GitHub地址](https://github.com/chen-1110)，谢谢各位了😄



## 引用：

* 尚硅谷宋红康老师jvm视频：https://www.bilibili.com/video/BV1PJ411n7xZ

* 《深入理解java虚拟机（第三版）》 周志明著

* 还有知乎以及其他互联网上多篇博客，就不一一引用了

谢谢大家！





###### 																																													