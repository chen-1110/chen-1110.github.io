---
layout: post
categories: 技术文章
author: chen
title: Java多线程博客3
---
### 悲观锁

取锁后会将之后其他线程取锁阻塞，直到上一个锁释放。`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。缺点是对于读多写少的高并发场景阻塞过多效率较差。

synchronized可以对对象加锁（修饰实例方法，代码块包裹对象），可以对类加锁（修饰静态方法，代码块包裹类）。底层原理是加锁是会维护一个monitor对象，其有int属性值，获取锁时会CAS操作，设置为1，解锁时设置为0，通过该标志位来互斥

![执行 monitorexit 释放锁](https://raw.githubusercontent.com/chen-1110/image/main/synchronized-release-lock-block.png)

synchronized有一些无锁，自旋锁的优化，减少锁获取成本。

#### reentrantLock和synchronized的区别

1.reentrantLock可以设置为公平或非公平，synchronized只能公平

2.reentrantLock可选择性唤醒（类似synchronized的wait/notify，只是lock对象可以new多个condition对象实现多个等待队列）

3.reentrantLock可设置超时，可以tryLock

4.reentrantLock可中断
ReentrantReadWriteLock，StampedLock读写锁可以多个线程同时读提高效率。

### 乐观锁

也称为无锁，并不会阻塞其他线程，读直接读，写操作通过CAS（原子操作，先比较expectValue和currentValue是否相等，若相等修改为newValue，如果不等不做修改）。java乐观锁使用的是unsafe包的native方compareAndSwap

还有一种乐观锁通过版本号来实现，版本号和值均和expect相等才会修改，该实现解决了CAS一大痛点ABA问题，即只比较值是否符合预期，可能会出现其他多线程修改了两次值碰巧与预期值相等。

乐观锁适合读多写少场景，在写多场景下大量失败性能不如悲观锁。乐观锁的典型实现在java.util.concurrent.atomic，其提供了基本类型AtomicInteger，AtomicLong，AtomicBoolean，数组类型，引用类型AtomicReference，

AtomicStampedReference（版本号避免ABA问题），对象属性修改类型AtomicIntegerFieldUpdater等。

