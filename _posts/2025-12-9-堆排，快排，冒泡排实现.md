---
layout: post
categories: 整理记录
author: chen
title: 堆排，快排，冒泡排实现
---
## 堆排

### 算法原理

堆排的对象是完全二叉树，完全二叉树等于数组，所以常见堆排对象也是数组，一般堆排分大根堆（正序），小根堆（逆序）两种，我们以大根堆为例

大根堆是指一个完全二叉树，其每一个根节点都大于其左右子树所有值

堆排序的步骤是

1.建立大根堆

建堆操作即为从最后一个节点到根节点循环，比较大小，左右子树父节点进行大小调整，注意发生调整后需要对调整的左右子树进行递归调整，初始建堆O(n)

2.将大根堆根节点与为节点交换，从而尾节点即为最大元素

3.对除了尾节点的数组重新调整为大根堆，由于之前交换了根节点，只需要对根节点递归的进行左右子树比较交换，O(logn)

4.循环重复2步骤，每次交换的节点为根节点和向左递减的尾节点

5.n次循环后，数组即为排序好的正序数组

总的复杂度为O（N*logN）

### 示例代码

（注意求前K大场景推荐用堆排实现）

```
    public void heapSort(int[] nums, int k) {
        // 大根堆堆排，只排后k个
        // 初始堆
        heapSortInit(nums);

        for (int i = 0; i < k; i++) {
            // 循环交换最后一个元素与堆顶元素
            int temp = nums[0];
            nums[0] = nums[nums.length - 1 - i];
            nums[nums.length - 1 - i] = temp;
            // 对堆顶进行堆调整
            heapAdjust(nums, 0, nums.length - 2 - i);
        }

    }

    public void heapAdjust(int[] nums, int index, int maxIndex) {
        int leftIndex = index * 2 + 1;
        Integer rightIndex = index * 2 + 2;
        if (leftIndex > maxIndex && rightIndex > maxIndex) {
            return;
        }

        Integer adjustIndex = heapSwap(nums, index, leftIndex, rightIndex, maxIndex);
        if (adjustIndex.equals(index)) {
            return;
        }
        heapAdjust(nums, adjustIndex, maxIndex);
    }

    public void heapSortInit(int[] nums) {
        int length = nums.length;
        for (int i = length - 1; i >= 0; i--) {
            Integer adjustIndex = 0;
            if (i % 2 == 1) {
                // 左节点
                adjustIndex = heapSwap(nums, ((i - 1) / 2), i, i + 1, nums.length - 1);
                if (adjustIndex.equals(((i - 1) / 2))) {
                    continue;
                }
            } else {
                // 右节点
                adjustIndex = heapSwap(nums, ((i - 2) / 2), i - 1, i, nums.length - 1);
                if (adjustIndex.equals((i - 2) / 2)) {
                    continue;
                }
            }
            // 子节点发生交换，需要对子节点调整建堆
            heapAdjust(nums, adjustIndex, nums.length - 1);
        }
    }

    public Integer heapSwap(int[] nums, Integer parentIndex, Integer leftIndex, Integer rightIndex, Integer maxIndex) {
        if (parentIndex < 0) {
            // 根节点特殊处理
            return parentIndex;
        }
        String max = "parent";
        int parent = nums[parentIndex];
        int left = nums[leftIndex];
        if (left > parent) {
            max = "left";
        }
        if (rightIndex <= maxIndex) {
            int right = nums[rightIndex];
            if (right > left && right > parent) {
                max = "right";
            }
        }
        if (max.equals("left")) {
            int temp = nums[parentIndex];
            nums[parentIndex] = nums[leftIndex];
            nums[leftIndex] = temp;
            return leftIndex;
        }
        if (max.equals("right")) {
            int temp = nums[parentIndex];
            nums[parentIndex] = nums[rightIndex];
            nums[rightIndex] = temp;
            return rightIndex;
        }
        return parentIndex;
    }
```

## 快排

### 算法原理

步骤：

1.数组中任选一元素（首尾，随机，中间均可），将小于该元素放左边，大于该元素放右边

2.对左右的子数组递归做该操作

每次递归，整个数组的步骤1耗时O(n)，需要进行logn轮操作，总时间复杂度NlogN，另外有些大神可以在原数组上进行步骤1，较复杂，也可以每次步骤1建个copy数组排好再复制上去，耗时翻倍但数量级仍为NlogN

### 示例代码

```
class Solution {
    public int[] sortArray(int[] nums) {
        int[] copyArray = new int[nums.length];
        sortArrayRecursion(nums, 0, nums.length - 1, copyArray);
        return nums;
    }

    public void sortArrayRecursion(int[] nums, int leftIndex, int rightIndex, int[] copyArray) {
        if (leftIndex >= rightIndex) {
            return;
        }
        int copyLeftIndex = leftIndex;
        int copyRightIndex = rightIndex;
        for (int i = leftIndex; i < rightIndex + 1; i++) {
            copyArray[i] = nums[i];
        }
        int lastValue = copyArray[rightIndex];
        for (int i = copyLeftIndex; i < copyRightIndex + 1; i++) {
            if (copyArray[i] < lastValue) {
                nums[leftIndex] = copyArray[i];
                leftIndex++;
            } else {
                nums[rightIndex] = copyArray[i];
                rightIndex--;
            }
        }
        nums[leftIndex] = lastValue;
        sortArrayRecursion(nums, copyLeftIndex, leftIndex - 1, copyArray);
        sortArrayRecursion(nums, leftIndex + 1, copyRightIndex, copyArray);
    }
}
```

## 冒泡排序

1.从左到右，两两比较，将更大的放在右边，最终尾部为最大元素

2.循环n次操作1，每次操作对象为头部到尾部-n位置

3.n次操作后数组为正序数组

时间复杂度O(N2)
