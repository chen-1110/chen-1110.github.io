---
layout: post
categories: 技术文章
author: chen
title: Redis面试题
---
#### 1. 常见的缓存更新策略

##### 旁路缓存模式

读场景，先查缓存，查不到查db，查到后写入缓存

写场景，先改db，改完删缓存

缓存命中率相较双写低一点，但也相当可以了

优势：一致性较强

缺点：

1.首次请求可能会把db打穿，可以考虑热点数据提前载入

2.会有小概率一致性问题，线程1读，缓存没有查db查出来数据A，线程2更新db为B，更新完删缓存，线程1再写入数据A，出现脏数据。概率较低因为缓存写要比db更新快1个数量级。

##### 双写

读场景，直接读缓存

写场景，先写db，再写缓存

优势：缓存命中率高

缺点：一致性较差，线程1写db数据A，线程2写db数据B，然后更新缓存B，线程1再写db数据A，出现脏数据。（解法可以在写场景用分布式锁包裹，锁力度是行数据id）

##### 异步写入缓存

核心思想是多次db写批量一次db写入，读取场景根据业务一致性和性能要求有多种策略，如只读db，或先读缓存再读db。

对于一致性要求不高场景如阅读量，消息红点数有较多应用，此外innodb buffer pool也是采用此思想

#### 2. redis分布式锁

setnx原子实现，建议使用redission的api，redission提供了看门狗机制，在不设置锁释放时间时，底层会将锁超时时间设置为30s，并且会自动检测当前线程是否存活，若存活会定期对锁超时时间续期到30s，从而保证锁不释放停机异常自动释放。

#### 3.redis五种基本数据类型

##### string

底层简单动态字符串SDS，对c字符串做了性能增强，包括获取字符串长度O(1)，避免内存移除，安全保存二进制数据

应用场景存json数据缓存，计数，分布式锁

##### list

底层双向链表实现，头尾均可操作，应用场景最新文章/动态，消息队列

##### hash

类似hashmap，底层数组+链表实现，应用场景存储对象缓存等

##### set

无序集合，类似hashset，应用场景uv统计，并交集关系共同关注，共同粉丝等

##### sorted set

排序集合，也叫zset，底层实现是跳表，常用作排行榜，排序数据的实现

#### 4. redis持久化机制

rdb：定期生成内存的快照存储在磁盘，可以快速恢复，可以配置主线程or子线程进行快照生成

aof：每次执行redis命令，记录一条日志，类似binlog

##### aof是先执行指令，再写aof的，不同于redolog，为什么？

1.只有指令成功才记录，不然如果写了aof但是指令失败了，没法回滚（redis不提供事务回滚能力）

2.redis是内存中操作，不同于redolog页操作需要先记录避免页毁坏无法恢复

3.这样同时带来问题，因为aof一般设置的时1s落库1次，redis崩溃可能会丢数据（可以设置每次指令阻塞写入 or 1s一次写入 or 30s一次写入）

当aof文件过大，会进行重写，压缩减少内存

redis4.0提供了混合持久化机制，会在aof重写时将rdb写在aof开头，便于快速恢复

#### 5. redis单线程模型

![文件事件处理器（file event handler）](https://raw.githubusercontent.com/chen-1110/image/main/redis-event-handler.png)

redis基于reactor模式使用单线程处理事件，多个客户端连接通过io多路复用单线程监听多个套接字实现

##### 为什么redis选择单线程

1.单线程无需处理锁，上下文切换等逻辑

2.redis指令设计简单，再由于其内存操作几乎没有磁盘io寻址等cpu耗费，瓶颈更多在网络io，单线程即可

##### redis多线程有了解吗

redis6.0后采用多线程处理网络io，核心计算仍用单线程处理

redis还有很多后台线程是多线程此操作的，比如aof，rdb，对象释放等操作

##### redis的key过期删除策略

redis的key过期删除采用定期删除+惰性删除结合的方式，具体的，redis底层会将键的过期时间存储在redisDb结构里

```c
typedef struct redisDb {
    ...

    dict *dict;     //数据库键空间,保存着数据库中所有键值对
    dict *expires   // 过期字典,保存着键的过期时间
    ...
} redisDb;
```

每次查询key的时候，会检查key是否在过期字典以及是否过期，如果过期会删除key并返回null，这就是惰性删除

定期删除的策略是，定时（默认10s）随机抽出一批key，删除过期的key，删除过程超过时间阈值（默认25ms）会结束循环，避免占用过多cpu，同时如果key的过期比例超过阈值（默认10%）也会继续执行删除流程

redis并不在key过期后将其立即删除，因为维护延时队列会占用cpu

#### 6. redis事务

无法保证原子性，持久性会有1s丢失，一般用lua脚本

#### 7. redis性能优化

##### 批量操作

采用mget等批处理指令

采用pipeline批量执行指令

##### 大key问题

可以通过--bigkeys来查找大key

可以用rdb采用一些现有工具分析大key（阿里云，redis-rdb-tools等）

大key分割，换数据结构，lazy-free

##### 热key问题

加二级缓存

#### 8. 缓存穿透，缓冲击穿，缓冲雪崩

##### 缓存穿透

大量查询既不在缓存，也不在数据库，db被打爆

解法：bloom filter， 服务限流/安全监控

##### 缓存击穿

热key过期，大量请求打爆db

解法：热key提前载入不过期，缓存过期重载操作加锁（较少见）

##### 缓存雪崩

大量key同时过期或redis实例不可用，db被打爆

解法：redis集群解决实例不可用，随即设置过期时间，缓存预热等解决key大量过期，

#### 9. redis cluster

将key取模16384，分到16384的槽上，每个redis 分片都是一个主从模型，多个分片分配这16384个槽，从而水平扩展

采用槽的设计可以避免按节点取余时，节点一增加大部分数据都要移动位置到不同分片，采用槽移动较少且明确。
