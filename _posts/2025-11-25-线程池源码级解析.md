---
layout: post
categories: æŠ€æœ¯æ–‡ç« 
author: chen
title: çº¿ç¨‹æ± æºç çº§è§£æ
---
## ä¸€ã€çŸ¥è¯†æ‰«ç›²

çº¿ç¨‹æ± æ˜¯ç®¡ç†ä¸€ç³»åˆ—çº¿ç¨‹çš„èµ„æºæ± ï¼Œå½“æœ‰ä»»åŠ¡è¦å¤„ç†æ—¶ï¼Œç›´æ¥ä»çº¿ç¨‹æ± ä¸­è·å–çº¿ç¨‹æ¥å¤„ç†ï¼Œå¤„ç†å®Œä¹‹åçº¿ç¨‹å¹¶ä¸ä¼šç«‹å³è¢«é”€æ¯ï¼Œè€Œæ˜¯ç­‰å¾…ä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚

çº¿ç¨‹æ± çš„ä¼˜ç‚¹æœ‰ï¼Œå‡å°‘çº¿ç¨‹é¢‘ç¹åˆ›å»º/é”€æ¯çš„ç³»ç»ŸæŸè€—ï¼Œé—²ç½®æ ¸å¿ƒçº¿ç¨‹æé«˜å“åº”é€Ÿåº¦ï¼Œæ›´å®Œå–„çš„çº¿ç¨‹ç®¡ç†èƒ½åŠ›ã€‚

## äºŒã€çº¿ç¨‹æ± åŸºæœ¬ä½¿ç”¨

#### åˆ›å»ºæ–¹å¼

1.é€šè¿‡ThreadPoolExecutoræ„é€ å‡½æ•°åˆ›å»º

çº¿ç¨‹æ± çš„å‡ ä¸ªé‡è¦å‚æ•°ï¼š

æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œæœ€å¤§çº¿ç¨‹æ•°ï¼Œè¶…æ—¶æ—¶é—´ï¼Œä»»åŠ¡é˜Ÿåˆ—ï¼Œæ‹’ç»ç­–ç•¥

2.é€šè¿‡Executorså·¥å…·ç±»ï¼ˆä¸æ¨èï¼‰

fixedThreadPoolï¼šå›ºå®šæ•°é‡çº¿ç¨‹æ± 

```
public class TestThreadPool {
    public static void main(String[] args) {
    ThreadFactory threadFactory = new ThreadFactoryBuilder()
                        .setNameFormat("chençš„æµ‹è¯•çº¿ç¨‹" + "-%d")
                        .setDaemon(true).build();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100), threadFactory);
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            threadPoolExecutor.execute(() -> System.out.println(finalI)); // or submit
        }

        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            executorService.execute(() -> System.out.println(finalI));
        }
    }
}
```

#### å¸¸ç”¨é˜»å¡é˜Ÿåˆ—æœ‰å“ªäº›

å®¹é‡ä¸º `Integer.MAX_VALUE` çš„ `LinkedBlockingQueue`ï¼šç›¸å½“äºæ— ç•Œé˜Ÿåˆ—ï¼Œå› ä¸ºæ°¸è¿œæ”¾ä¸æ»¡ï¼Œæ”¾æ»¡å‰å°±OOMäº†

SynchronousQueueï¼š0å®¹é‡ï¼Œæ¯æ¬¡éƒ½ä¼šèµ°æ‹’ç»ç­–ç•¥

æœ‰ç•Œçš„ArrayBlockingQueueå’ŒLinkedBlockingQueue

#### å¸¸ç”¨æ‹’ç»ç­–ç•¥æœ‰å“ªäº›

AbortPolicyï¼šç›´æ¥æŠ›å¼‚å¸¸

CallerRunsPolicyï¼šç”±è°ƒç”¨çº¿ç¨‹ç›´æ¥æ‰§è¡Œ

DiscardPolicyï¼šç›´æ¥ä¸¢å¼ƒ

#### ä¸å…è®¸ä¸¢ï¼Œåˆæ‹…å¿ƒOOMï¼Œæ€ä¹ˆåš

è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥ï¼Œå†™å…¥æ•°æ®åº“

ç»§æ‰¿blockingqueueï¼Œé‡å†™takeæ–¹æ³•ï¼Œå–ä»»åŠ¡å…ˆå–æ•°æ®åº“ï¼Œå†å–queueé‡Œæ•°æ®

#### å¦‚ä½•è®¾ç½®çº¿ç¨‹æ•°

å¹¶æ— é“¶å¼¹åšæ³•ï¼Œå‚è€ƒç½‘ä¸Šæµä¼ cpuå¯†é›†N+1ï¼Œioå¯†é›†å‹2Nï¼Œä½†å¹¶ä¸æ¨èä¸¥æ ¼éµå¾ªï¼Œå¯ä»¥å‚è€ƒç¾å›¢çš„åŠ¨æ€é…ç½®https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html

![img](https://raw.githubusercontent.com/chen-1110/image/main/23a44974ff68a08261fb675242b83648181953.png)

![åŠ¨æ€é…ç½®çº¿ç¨‹æ± å‚æ•°æœ€ç»ˆæ•ˆæœ](https://raw.githubusercontent.com/chen-1110/image/main/meituan-dynamically-configuring-thread-pool-parameters.png)

## ä¸‰ã€çº¿ç¨‹æ± æºç è§£æ

### 3.1ä¸»çº¿

æˆ‘ä»¬åˆ†æçº¿ç¨‹æ± æºç çš„ä¸»çº¿æ˜¯ï¼Œä»æäº¤ä»»åŠ¡ä¸ºå…¥å£å¼€å§‹ï¼Œçœ‹æ–°ä»»åŠ¡æ¥äº†ä¹‹åçº¿ç¨‹æ± çš„æ‰§è¡Œé€»è¾‘ï¼Œåœ¨åˆ†æçš„è¿‡ç¨‹ä¸­åŒæ—¶çœ‹çœ‹å‡ ä¸ªé¢è¯•å¸¸è§é—®é¢˜æ˜¯å¦‚ä½•ä»æºç ä¸­å¾—åˆ°ç­”æ¡ˆçš„ã€‚ä¸‹å›¾æ˜¯ç½‘ä¸Šå…«è‚¡å¸¸æœ‰çš„çº¿ç¨‹æŒå¤„ç†ä»»åŠ¡æµç¨‹ã€‚

![å›¾è§£çº¿ç¨‹æ± å®ç°åŸç†](https://raw.githubusercontent.com/chen-1110/image/main/thread-pool-principle.png)

åœ¨ä¸Šä¸€èŠ‚åˆ›å»ºæ–¹å¼é‡Œå·²ç»å±•ç¤ºäº†çº¿ç¨‹æ± ä½¿ç”¨çš„demoï¼Œä¸€èˆ¬æäº¤æ–°ä»»åŠ¡å¯ä»¥ç”¨threadPoolExecutorçš„execute/submitæ–¹æ³•ï¼Œæˆ‘ä»¬å…ˆä»¥executeæ–¹æ³•æ¥å…¥æ‰‹ï¼Œåé¢ä¼šè®²ä¸‹äºŒè€…çš„å”¯ä¸€çš„åŒºåˆ«ã€‚

### 3.2é‡è¦æˆå‘˜å˜é‡

åœ¨è®²executeæ–¹æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹threadPoolExecutorçš„å¸¸ç”¨çš„æˆå‘˜å˜é‡ï¼Œä¸ç„¶æ¥ä¸‹æ¥çš„æ–¹æ³•ä¸­ç›´æ¥ä½¿ç”¨å¯èƒ½ä¸å¥½ç†è§£ã€‚è§ä»¥ä¸‹ï¼Œ

```
public class ThreadPoolExecutor extends AbstractExecutorService {
	private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
	private final BlockingQueue<Runnable> workQueue;
	private final ReentrantLock mainLock = new ReentrantLock();
	private final HashSet<Worker> workers = new HashSet<Worker>();
	
	private static int runStateOf(int c)     { return c & ~CAPACITY; }
    private static int workerCountOf(int c)  { return c & CAPACITY; }
}
```

**ctl**

ctlæ˜¯ä¸€ä¸ªåŸå­intç±»ï¼Œä½¿ç”¨äº†ç‹¬ç‰¹çš„ä½è¿ç®—ï¼Œä¸€ä¸ªintå€¼åŒ…å«äº†ä¸¤ç§å±æ€§ä¿¡æ¯ï¼Œå…·ä½“æ¥è¯´å…¶32ä½ä¸­é«˜3ä½ç”¨æ¥è®°å½•æ•´ä¸ªçº¿ç¨‹æ± çš„å·¥ä½œçŠ¶æ€ï¼Œä½29ä½ç”¨æ¥è®°å½•çº¿ç¨‹æ± ä¸­workerçš„æ•°é‡ã€‚å…¶åŒ…è£…äº†runStateOf()è·å–å·¥ä½œçŠ¶æ€ï¼ŒworkerCountOf()è·å–workeræ•°é‡

**workQueue**

ä¸€ä¸ªæŠ½è±¡ç±»blockingQueueï¼Œå…¶å°±æ˜¯åˆ›å»ºçº¿ç¨‹æ—¶é€‰æ‹©çš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œåˆ›å»ºæ—¶å¯ä»¥ä¼ å…¥å…¶å®ç°ç±»ï¼Œå®ç°æœ‰æ— ç•Œ/é•¿åº¦ç­‰æ§åˆ¶ã€‚æŠ½è±¡ç±»blockingQueueçš„ä¸€å¤§ç‰¹ç‚¹æ˜¯ï¼Œå…¶å¤§éƒ¨åˆ†å®ç°ç±»é€šè¿‡wait/notifyï¼ˆawait/signalï¼‰æœºåˆ¶ä¿è¯å‡ºé˜Ÿåˆ—takeæ—¶ï¼Œè‹¥é˜Ÿåˆ—æ— å…ƒç´ ï¼Œçº¿ç¨‹é˜»å¡ç­‰å¾…ï¼Œå¾…å…ƒç´ å…¥é˜Ÿåˆ—æ—¶å”¤é†’ï¼Œä»è€Œé¿å…çº¿ç¨‹ç©ºè½¬è·å–ä»»åŠ¡ï¼Œæé«˜æ€§èƒ½

**mainLock**

æ–¹æ³•å†…åŠ é”ç”¨

**workers**

æ‰€æœ‰å·¥ä½œçº¿ç¨‹ç”¨Workerå¯¹è±¡å­˜å‚¨ï¼Œworkersæ˜¯æ‰€æœ‰å·¥ä½œçº¿ç¨‹çš„é›†åˆã€‚å…¶æ•°æ®ç»“æ„å¦‚ä¸‹ï¼Œå…¶ä¸»è¦æˆå‘˜å¦‚ä¸‹ï¼Œ

**thread**

ä¼šåœ¨æ„é€ å‡½æ•°é‡Œå°†å½“å‰è‡ªå·±å¯¹è±¡æœ¬èº«åˆ›å»ºçº¿ç¨‹ï¼Œä½¿ç”¨æ—¶ç›´æ¥ç”¨è¯¥thread.start()å¯åŠ¨çº¿ç¨‹ã€‚ï¼ˆä¸å¸¸è§çš„ç”¨æ—¶æ–°å»ºthreadå¯¹è±¡ï¼Œä¼ å…¥runnableæ„é€ ä¸åŒï¼Œè¿™æ ·æ“ä½œæ›´ç®€æ˜“ï¼‰

**firstTask**

workeråˆå§‹åŒ–æ—¶å¯è®¾ç½®firstTaskï¼Œå¯åŠ¨åç›´æ¥å¹²æ´»ğŸ˜

```
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
        
        public Thread newThread(Runnable r) {
            Thread t = new Thread(group, r,
                                  namePrefix + threadNumber.getAndIncrement(),
                                  0);
            if (t.isDaemon())
                t.setDaemon(false);
            if (t.getPriority() != Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            return t;
        }
}
```

æ­¤å¤–åˆšæ‰è®²åˆ°çš„å‰©ä¸‹çš„åˆ›å»ºæ—¶çš„ä¼ å‚ä¹Ÿåœ¨å…¶ä¸­æœ‰å„è‡ªå¯¹åº”çš„æˆå‘˜å˜é‡å¦‚ä¸‹

```
// æ ¸å¿ƒçº¿ç¨‹æ•°
private volatile int corePoolSize;
// æœ€å¤§çº¿ç¨‹æ•°
private volatile int maximumPoolSize;
// éæ ¸å¿ƒçº¿ç¨‹å­˜æ´»æ—¶é—´
private volatile long keepAliveTime;
// æ‹’ç»ç­–ç•¥
private volatile RejectedExecutionHandler handler;
// ä»¥ä¸‹éå¸¸è§ä½¿ç”¨ï¼Œå¯å…ˆä¸å…³æ³¨


// æ ¸å¿ƒçº¿ç¨‹è¶…æ—¶æ—¶é—´ï¼Œå¯ä»¥å°†æ ¸å¿ƒçº¿ç¨‹ä¹Ÿè®¾ç½®ä¸ºè¶…æ—¶å›æ”¶é€»è¾‘
private volatile boolean allowCoreThreadTimeOut;
// çº¿ç¨‹åˆ›å»ºå·¥å‚ï¼Œä¸€èˆ¬é»˜è®¤ä¸åšé¢å¤–é€»è¾‘
private volatile ThreadFactory threadFactory;
```

### 3.3ä»»åŠ¡æ‰§è¡Œexecute()

```
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

ä¸Šé¢æ˜¯executeçš„æºç 

1.å¦‚æœworkeræ•°é‡å°äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œè°ƒç”¨addWorker()å¢åŠ æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œå¦‚æœaddWorkerå¤±è´¥äº†èµ°åç»­é€»è¾‘

â€‹	ps.ä»€ä¹ˆæƒ…å†µä¸‹ä¼šå¤±è´¥å‘¢ï¼Œåé¢ä¼šçœ‹addWorkerçš„æºç ï¼Œä¸€ä¸ªå…¸å‹åœºæ™¯æ˜¯workerCountOfå¯èƒ½è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹äº†ï¼Œè¶…å‡ºäº†æ ¸å¿ƒçº¿ç¨‹æ•°

2.å¦‚æœçº¿ç¨‹æ± è¿˜åœ¨runningï¼Œè°ƒç”¨offerå°†ä»»åŠ¡å…¥é˜Ÿåˆ—ï¼Œè‹¥å…¥é˜ŸæˆåŠŸåï¼Œ

â€‹	2.1å†æ¬¡æ£€æŸ¥æ˜¯å¦runningï¼Œè‹¥érunningå°†ä»»åŠ¡å‡ºé˜Ÿï¼Œå¦‚æœèƒ½å‡ºé˜ŸæˆåŠŸï¼Œè°ƒç”¨rejectèµ°æ‹’ç»ç­–ç•¥é€»è¾‘ã€‚

â€‹	2.2è‹¥æ˜¯érunningçŠ¶æ€æˆ–è€…å‡ºé˜Ÿå¤±è´¥ï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰å­˜æ´»workerï¼Œè‹¥æ²¡æœ‰è°ƒaddWorker()è¡¥ä¸€ä¸ªä¿è¯è¿™ä¸ªç ´ä»»åŠ¡æœ€ç»ˆä¸€å®šæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å°†å®ƒæ‰§è¡Œã€‚

3.å¦‚æœ2æ­¥éª¤ä¸­å…¥é˜Ÿå¤±è´¥ï¼Œè°ƒç”¨addWorker()å¢åŠ éæ ¸å¿ƒçº¿ç¨‹æ•°ï¼ŒaddWorkeré€»è¾‘é‡Œæœ‰åˆ¤æ–­æ˜¯å¦è¶…è¿‡æœ€å¤§çº¿ç¨‹ï¼ˆåé¢ä¼šå±•å¼€çœ‹ï¼‰ï¼Œè‹¥è¶…è¿‡ä¼šè¿”å›falseï¼Œå¢åŠ å¤±è´¥ï¼Œæ­¤æ—¶è°ƒç”¨rejectèµ°æ‹’ç»ç­–ç•¥é€»è¾‘

![å›¾è§£çº¿ç¨‹æ± å®ç°åŸç†](https://raw.githubusercontent.com/chen-1110/image/main/thread-pool-principle.png)

### 3.4å¢åŠ çº¿ç¨‹æ•°addWorker()

æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹å¢åŠ çº¿ç¨‹æ•°çš„æ–¹æ³•çš„é€»è¾‘ï¼Œè®¾è®¡æ€è·¯ä¸Šï¼Œå…¥å‚æœ‰ä¸¤ä¸ªï¼Œrunnableç±»å‹çš„firstTaskï¼Œè‹¥énullåˆ›å»ºçº¿ç¨‹åä¾¿å¯ä»¥ç›´æ¥æ‰§è¡Œæ— éœ€åœ¨é˜Ÿåˆ—æ‹‰å–ä»»åŠ¡ï¼Œboolç±»å‹çš„coreï¼Œæ ‡å¿—è¦åˆ›å»ºçš„æ˜¯å¦ä¸ºæ ¸å¿ƒçº¿ç¨‹

æˆ‘ä»¬çœ‹ä¸‹æºç åšäº†ä»€ä¹ˆ

1.å¢åŠ ä¹‹å‰å…ˆprecheckä¸‹çº¿ç¨‹æ± è¦å…³äº†é˜Ÿåˆ—æ˜¯ä¸æ˜¯ç©ºäº†ï¼Œå¦‚æœæ˜¯å°±ä¸åˆ›å»º

2.åˆ¤æ–­å½“å‰çš„workeræ•°æœ‰æ²¡æœ‰è¶…è¿‡é˜ˆå€¼ï¼ˆæ ¸å¿ƒçº¿ç¨‹æ•°/æœ€å¤§çº¿ç¨‹æ•°ï¼‰ï¼Œæœ‰æ²¡æœ‰è¶…è¿‡capacityï¼ˆä½29ä½æœ€é«˜å€¼ï¼Œä¿æŠ¤é€»è¾‘è‚¯å®šä¸ä¼šèµ°åˆ°ï¼Œèµ°åˆ°è¯¥é€»è¾‘å‰å°±OOMäº†ï¼‰ï¼Œå¦‚æœè¶…è¿‡é˜ˆå€¼äº†ç›´æ¥è¿”å›falseå¤±è´¥

3.æ–°å»ºä¸€ä¸ªworkerï¼ˆæ„é€ å‡½æ•°å‚æ•°æœ‰firstTaskï¼‰ï¼ŒåŠ é”åŠ å…¥workersé›†åˆï¼Œå¯åŠ¨workeré‡Œçš„threadçº¿ç¨‹ï¼Œä»è€Œæ‰§è¡Œworkerçš„runå‡½æ•°ï¼Œå¦‚æœæ‰§è¡Œæœ‰å¼‚å¸¸ä¹Ÿä¼šæœ‰æ¸…ç†ä¿æŠ¤ä»£ç ã€‚

```
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

### 3.5çº¿ç¨‹workerçš„runå‡½æ•°

#### runé€»è¾‘

å–å‡ºfirstTaskï¼Œè‹¥éç©ºæ‰§è¡Œtaskçš„ä»»åŠ¡ï¼ŒåŒæ—¶å¾ªç¯getTask()å–workQueueçš„ä»»åŠ¡

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„é€»è¾‘æ˜¯ï¼Œåœ¨ç¬¬28è¡Œä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œåœ¨44è¡Œæ•è·åï¼ŒcompletedAbruptlyä¸ºfalseï¼Œä¼šåœ¨processWorkerExit()é€»è¾‘é‡Œåˆ›å»ºæ–°çš„workerèŠ‚ç‚¹ï¼ŒåŸworkèŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸç»“æŸ

ps.æºç é‡Œæœ‰ä¸€äº›ä¸å¤ªå…³é”®çš„åˆ†æ”¯é€»è¾‘ï¼Œç®€å•è®²ä¸‹ï¼Œæ¯”å¦‚ä¼šå–å½“å‰çº¿ç¨‹ï¼Œå¦‚æœæ˜¯å¯ä»¥è¢«interuptä¸”è¢«interuptä¼šè·³å‡ºå¾ªç¯ç»“æŸé€»è¾‘æ­»äº¡ã€‚æ­¤å¤–æœ‰ä¸€äº›beforeï¼Œafterçš„é’©å­å‡½æ•°ï¼Œéƒ½æ˜¯ç©ºå®ç°ã€‚

```
    public void run() {
        runWorker(this);
    }  
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

#### å»¶ä¼¸submit()çš„é€»è¾‘åŒºåˆ«

> æœ‰ä¸€ä¸ªå»¶ä¼¸çš„éå…³é”®é€»è¾‘ï¼Œæˆ‘ä»¬åœ¨ä½¿ç”¨çº¿ç¨‹æ± execute()æ‰§è¡Œä»»åŠ¡ä¼šæŒ‰ç…§ä¸Šé¢æ‰€è¯´ï¼Œè‹¥ä»»åŠ¡é€»è¾‘æŠ›äº†å¼‚å¸¸æ‰§è¡Œçº¿ç¨‹ä¼šç»ˆæ­¢ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ï¼Œä½†æ˜¯å¦‚æœä½¿ç”¨submit()æ—¶å‘ç”Ÿå¼‚å¸¸è¡¨è±¡å¹¶ä¸ç›¸åŒï¼Œæ‰§è¡Œçº¿ç¨‹ä¸ä¼šç»ˆæ­¢ä¼šç»§ç»­æ‰§è¡Œï¼Œä¹Ÿä¸ä¼šåˆ›å»ºæ–°çš„çº¿ç¨‹ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Œæˆ‘ä»¬å¯ä»¥ä»æºç ä¸­å¾—åˆ°ç­”æ¡ˆï¼Œè§ä¸‹æ–¹ï¼Œsubmitæ–¹æ³•åªæ˜¯å°†taskåŒ…è£…æˆå®ç°äº†runnableçš„å­ç±»RunnableFutureï¼Œæ¥ç€å°±ç»§ç»­executeæ–¹æ³•åŒæ ·çš„é€»è¾‘æ‰§è¡Œäº†ã€‚
>
> ```
>     public Future<?> submit(Runnable task) {
>         if (task == null) throw new NullPointerException();
>         RunnableFuture<Void> ftask = newTaskFor(task, null);
>         execute(ftask);
>         return ftask;
>     }
> ```
>
> é‚£ä¹ˆé—®é¢˜å°±åœ¨è¿™ä¸ªRunnableFutureä¸Šï¼Œè¿›å…¥æºç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å…¶åˆ›å»ºäº†ä¸€ä¸ªfutureTaskï¼Œè¯¥futureTaské‡å†™äº†åŸæœ¬taskçš„runæ–¹æ³•ï¼ˆæ³¨æ„è¿™ä¸ªrunæ˜¯taskçš„ï¼Œè·Ÿworkerçš„runä¸ä¸€æ ·ï¼Œworkerçš„runé‡Œé¢ä¼šè°ƒç”¨taskçš„runï¼‰ï¼Œå¦‚ä¸‹åœ¨20è¡Œcatchåˆ°å¼‚å¸¸åä¸ä¼šç»§ç»­å¾€ä¸ŠæŠ›ï¼Œä»è€Œä¸ä¼šç»ˆæ­¢æ‰§è¡Œçº¿ç¨‹
>
> ```
>     protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
>         return new FutureTask<T>(runnable, value);
>     }
>     public void run() {
>         if (state != NEW ||
>             !UNSAFE.compareAndSwapObject(this, runnerOffset,
>                                          null, Thread.currentThread()))
>             return;
>         try {
>             Callable<V> c = callable;
>             if (c != null && state == NEW) {
>                 V result;
>                 boolean ran;
>                 try {
>                     result = c.call();
>                     ran = true;
>                 } catch (Throwable ex) {
>                     result = null;
>                     ran = false;
>                     setException(ex);
>                 }
>                 if (ran)
>                     set(result);
>             }
>         } finally {
>             // runner must be non-null until state is settled to
>             // prevent concurrent calls to run()
>             runner = null;
>             // state must be re-read after nulling runner to prevent
>             // leaked interrupts
>             int s = state;
>             if (s >= INTERRUPTING)
>                 handlePossibleCancellationInterrupt(s);
>         }
>     }
> ```

#### getTask()é€»è¾‘

æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹getTaskçš„æ‰§è¡Œé€»è¾‘ï¼Œå°±èƒ½å¤ŸçŸ¥é“çº¿ç¨‹æ± å¦‚ä½•å®ç°éæ ¸å¿ƒçº¿ç¨‹è¶…æ—¶é”€æ¯çš„ã€‚å¦‚ä¸‹æºç 

1.åŒæ ·çš„precheckï¼Œæ£€æŸ¥çº¿ç¨‹æ± æ˜¯ä¸æ˜¯è¦å…³äº†ï¼Œå¦‚æœæ˜¯å‡å°‘workCountæ•°ï¼Œç»“æŸé€»è¾‘

2.åˆ¤æ–­è¯¥çº¿ç¨‹è¦ä¸è¦èµ°è¶…æ—¶å›æ”¶é€»è¾‘ï¼Œå…·ä½“é€»è¾‘æ˜¯ï¼Œå¯¹äºéæ ¸å¿ƒçº¿ç¨‹ï¼Œç”¨æœ‰è¶…æ—¶é—´çš„pollå–é˜Ÿåˆ—ï¼Œè¶…æ—¶æ—¶é—´æ˜¯keepAliveTimeï¼Œè¶…æ—¶åä¼šcaså‡å°‘countæ•°ç„¶åè·³å‡ºå¾ªç¯ã€‚å¯¹äºæ ¸å¿ƒçº¿ç¨‹ï¼Œçº¿ç¨‹æ± ä¹Ÿæä¾›äº†å¯ä»¥è¶…æ—¶å›æ”¶çš„èƒ½åŠ›ï¼Œåªæ˜¯ä¸€èˆ¬ä½¿ç”¨ä¸Šä¸ç”¨è¯¥èƒ½åŠ›ï¼Œåœ¨3.2æˆå‘˜å˜é‡é‡Œæœ‰æ ‡æ³¨ä¸€ä¸ªéé‡è¦çš„å˜é‡allowCoreThreadTimeOutï¼Œåœ¨åˆ›å»ºçº¿ç¨‹æ± åå¯ä»¥è°ƒç”¨allowCoreThreadTimeOut()æ–¹æ³•è®¾ç½®è¯¥å˜é‡ï¼Œè‹¥è®¾ç½®äº†ä¼šç±»ä¼¼éæ ¸å¿ƒçº¿ç¨‹ï¼Œç”¨å¸¦è¶…æ—¶æ—¶é—´çš„pollå–é˜Ÿåˆ—ï¼Œè¶…æ—¶æ—¶é—´å°±æ˜¯allowCoreThreadTimeOut

```
    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```



